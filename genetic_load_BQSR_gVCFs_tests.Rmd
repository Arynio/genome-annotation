---
title: "genetic_load_BQSR_gVCFs_tests"
author: "Dani"
date: "19 de noviembre de 2018"
output: html_document
---

This script will be used to test whether the BQSR or the gVCFs are responsible for the strange behaviour of number of variants (particularly of coding variants) between the lp genome project and the lp 5x datasets. For this purpose, at first I wanted to use the first 8 scaffolds of the genome (all lp individuals), but I can't obtain healthy gVCFs for 8 scaffolds only so I'll do it for the whole genome, but using two individuals only: lp_sm_0134 (5x project) and lp_sm_0138 (GP).

#0: Define paths.

```{r Define paths, eval=FALSE, engine='bash'}

#Subset the reference:
samtools faidx /home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa lp23.s00001 lp23.s00002 lp23.s00003 lp23.s00004 lp23.s00005 lp23.s00006 lp23.s00007 lp23.s00008 > /home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23_first_eight_scaffolds.fa
#I generated the .fai and .dict.
#Also a .bed using: awk 'BEGIN {FS="\t"}; {print $1 FS "0" FS $2}' lp23_first_eight_scaffolds.fa.fai > lp23_first_eight_scaffolds.bed

#Paths:
S_PATH=/opt/snpEff #software path
C_PATH=/home/dkleinman/datos/snpEff #config file path
O_PATH=/home/dkleinman/datos/snpEff #output path
I_PATH=/home/GRUPOS/grupolince/immunocapture/prueba_highdiv #immunocapture path
V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path
G_PATH=/GRUPOS/grupolince/lynx_genomes_5x/gVCFs #gVCFs path
REF=/home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa #path to reference genome (first eight scaffolds only)
GATK=/opt/GATK-3.7/GenomeAnalysisTK.jar #GATK software path
BCF=/opt/bcftools-1.6/bcftools #BCFtools software path

```

#1: Perform different callings.
##A: Recalibrated BAMs, VCF via gVCFs.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Perform variant calling (via gVCFs) on the recalibrated BAMs. The calling was already obtained for the whole-genome as part of the main scripts. Here we'll just subset the first eight scaffolds.

cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_recal_gVCF_on.log
script c_lp_sm_c_lp_do_BAM_recal_gVCF_on.log

cd /GRUPOS/grupolince/lynx_genomes_5x/gVCFs
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -jar $GATK \
-T GenotypeGVCFs \
-R $REF \
$(for var in c_{lp_sm_0134*,lp_sm_0138*}recal_round-1.g.vcf.gz; do echo -V ${var}" "; done) \
-o $V_PATH/c_lp_sm_c_lp_do_BAM_recal_gVCF_on.vcf

cd $V_PATH
grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_on.vcf | wc -l #2025478


```

##B: Recalibrated BAMs, direct VCF.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Perform direct variant calling (without gVCFs) on the recalibrated BAMs.
cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_recal_gVCF_off.log
script c_lp_sm_c_lp_do_BAM_recal_gVCF_off.log

cd $V_PATH
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -jar $GATK \
-T HaplotypeCaller \
-R $REF \
$(for var in /home/GRUPOS/grupolince/lynx_genomes_5x/BAM_files_final/c_{lp_sm_0134*,lp_sm_0138*}recal_round-1.bam; do echo -I ${var}" ";done) \
-o $V_PATH/c_lp_sm_c_lp_do_BAM_recal_gVCF_off.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_off.vcf | wc -l #2030604

```

##C: Original BAMs, direct VCF.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Perform direct variant calling (without gVCFs), on the original BAMs (without recalibration).
cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_origi_gVCF_off.log
script c_lp_sm_c_lp_do_BAM_origi_gVCF_off.log

cd /backup/grupolince/BAM_files_Lynx/BAM_indelrealigner_before_recal/LYNX_06_08_09_GENOME_PROJECT
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -jar $GATK \
-T HaplotypeCaller \
-R $REF \
$(for var in c_{lp_sm_0134*,lp_sm_0138*}sorted_indelrealigner.bam; do echo -I ${var}" ";done) \
-o $V_PATH/c_lp_sm_c_lp_do_BAM_origi_gVCF_off.vcf

cd $V_PATH
grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_off.vcf | wc -l #2502228

```

##D: Original BAMs, VCF via gVCFs.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Obtain gVCF for lp_sm_0134's original BAMs:
cd /backup/grupolince/BAM_files_Lynx/BAM_indelrealigner_before_recal/LYNX_06_08_09_GENOME_PROJECT
screen -S c_lp_sm_0134_sorted_rmdup_sorted_indelrealigner.g.vcf.log
script c_lp_sm_0134_sorted_rmdup_sorted_indelrealigner.g.vcf.log

cd /backup/grupolince/BAM_files_Lynx/BAM_indelrealigner_before_recal/LYNX_06_08_09_GENOME_PROJECT
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -jar $GATK \
-T HaplotypeCaller \
-R /home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa \
-I c_lp_sm_0134_sorted_rmdup_sorted_indelrealigner.bam \
--emitRefConfidence GVCF \
-o /backup/grupolince/BAM_files_Lynx/BAM_indelrealigner_before_recal/LYNX_06_08_09_GENOME_PROJECT/gVCFs/c_lp_sm_0134_sorted_rmdup_sorted_indelrealigner.g.vcf.gz


#Obtain gVCFs for lp_sm_0138's original BAMs:
cd /backup/grupolince/BAM_files_Lynx/BAM_indelrealigner_before_recal/LYNX_06_08_09_GENOME_PROJECT
screen -S c_lp_sm_0138_sorted_rmdup_sorted_indelrealigner.g.vcf.log
script c_lp_sm_0138_sorted_rmdup_sorted_indelrealigner.g.vcf.log

cd /backup/grupolince/BAM_files_Lynx/BAM_indelrealigner_before_recal/LYNX_06_08_09_GENOME_PROJECT
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -jar $GATK \
-T HaplotypeCaller \
-R /home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa \
-I c_lp_sm_0138_sorted_rmdup_sorted_indelrealigner.bam \
--emitRefConfidence GVCF \
-o /backup/grupolince/BAM_files_Lynx/BAM_indelrealigner_before_recal/LYNX_06_08_09_GENOME_PROJECT/gVCFs/c_lp_sm_0138_sorted_rmdup_sorted_indelrealigner.g.vcf.gz


#Perform variant calling (via gVCFs which are also generated here), on the original BAMs (without recalibration).
cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_origi_gVCF_on.log
script c_lp_sm_c_lp_do_BAM_origi_gVCF_on.log

#cd /backup/grupolince/BAM_files_Lynx/BAM_indelrealigner_before_recal/LYNX_06_08_09_GENOME_PROJECT/gVCFs/
#for var in *.g.vcf.gz; do tabix -p vcf ${var}; done 

cd /backup/grupolince/BAM_files_Lynx/BAM_indelrealigner_before_recal/LYNX_06_08_09_GENOME_PROJECT/gVCFs/
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -jar $GATK \
-T GenotypeGVCFs \
-R $REF \
$(for var in c_{lp_sm_0134*,lp_sm_0138*}sorted_rmdup_sorted_indelrealigner.g.vcf.gz; do echo -V ${var}" "; done) \
-o $V_PATH/c_lp_sm_c_lp_do_BAM_origi_gVCF_on.vcf

cd $V_PATH
grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_on.vcf | wc -l #2517030

```

#1: Polarize contemporary VCF. Use VCFtools in order to polarize (ancestral vs. derived) the contemporary ll & lp VCF (obtained in ll_phylogeography_VCFs script). The ancestral state was inferred by Maria.

##Use vcftools to fill the INFO/AA field of the VCF.
###Prepare AA file.

```{r Polarize contemporary VCF, eval=FALSE, engine='bash'}

#This is the command to use in order to add to a VCF information on the ancestral/derived alleles: /opt/vcftools_0.1.13/perl/fill-aa. There's documentation inside that command that I'll follow here.

#First, the ancestral alleles file should be bgzipped (according to the documentation, they should be gzipped, but later on when trying to run faidx I got an error stating that files should be gzipped in order to build a fai index):
bgzip -c /home/GRUPOS/grupolince/reference_genomes/lynx_rufus_genome/c_lr_zz_0001_recal1.fa > /home/GRUPOS/grupolince/reference_genomes/lynx_rufus_genome/c_lr_zz_0001_recal1.fa.gz

#Next they should be fai indexed:
/opt/samtools-1.6/samtools faidx /home/GRUPOS/grupolince/reference_genomes/lynx_rufus_genome/c_lr_zz_0001_recal1.fa.gz


```

###A: Recalibrated BAMs, VCF via gVCFs.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Perform ancestral allele filling.

cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_recal_gVCF_on_aafilled.log
script c_lp_sm_c_lp_do_BAM_recal_gVCF_on_aafilled.log

export PERL5LIB=/opt/vcftools_0.1.13/perl/ #set required environmental variable
V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path

cat $V_PATH/c_lp_sm_c_lp_do_BAM_recal_gVCF_on.vcf | /opt/vcftools_0.1.13/perl/fill-aa -a /home/GRUPOS/grupolince/reference_genomes/lynx_rufus_genome/c_lr_zz_0001_recal1.fa.gz | bgzip -c > c_lp_sm_c_lp_do_BAM_recal_gVCF_on_aafilled.vcf.gz #I tried to run this first without bgzipping it, and it was increasingly slow. Each day it did around half the previous day. When the server crashed, I relaunched it adding the bgzip command and it finished in a little over 24h.

gzip -d -c c_lp_sm_c_lp_do_BAM_recal_gVCF_on_aafilled.vcf.gz > c_lp_sm_c_lp_do_BAM_recal_gVCF_on_aafilled.vcf #Get decompressed version. I ran md5sum for both the gzipped and the unzipped versions and there were no differences.

cd $V_PATH
grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_on_aafilled.vcf | wc -l #2025478

```

###B: Recalibrated BAMs, direct VCF.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Perform ancestral allele filling.

cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_recal_gVCF_off_aafilled.log
script c_lp_sm_c_lp_do_BAM_recal_gVCF_off_aafilled.log

export PERL5LIB=/opt/vcftools_0.1.13/perl/ #set required environmental variable
V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path

cat $V_PATH/c_lp_sm_c_lp_do_BAM_recal_gVCF_off.vcf | /opt/vcftools_0.1.13/perl/fill-aa -a /home/GRUPOS/grupolince/reference_genomes/lynx_rufus_genome/c_lr_zz_0001_recal1.fa.gz | bgzip -c > c_lp_sm_c_lp_do_BAM_recal_gVCF_off_aafilled.vcf.gz #I tried to run this first without bgzipping it, and it was increasingly slow. Each day it did around half the previous day. When the server crashed, I relaunched it adding the bgzip command and it finished in a little over 24h.

gzip -d -c c_lp_sm_c_lp_do_BAM_recal_gVCF_off_aafilled.vcf.gz > c_lp_sm_c_lp_do_BAM_recal_gVCF_off_aafilled.vcf #Get decompressed version. I ran md5sum for both the gzipped and the unzipped versions and there were no differences.

cd $V_PATH
grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_off_aafilled.vcf | wc -l #2030604

```

###C: Original BAMs, direct VCF.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Perform ancestral allele filling.

cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_origi_gVCF_off_aafilled.log
script c_lp_sm_c_lp_do_BAM_origi_gVCF_off_aafilled.log

export PERL5LIB=/opt/vcftools_0.1.13/perl/ #set required environmental variable
V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path

cat $V_PATH/c_lp_sm_c_lp_do_BAM_origi_gVCF_off.vcf | /opt/vcftools_0.1.13/perl/fill-aa -a /home/GRUPOS/grupolince/reference_genomes/lynx_rufus_genome/c_lr_zz_0001_recal1.fa.gz | bgzip -c > c_lp_sm_c_lp_do_BAM_origi_gVCF_off_aafilled.vcf.gz #I tried to run this first without bgzipping it, and it was increasingly slow. Each day it did around half the previous day. When the server crashed, I relaunched it adding the bgzip command and it finished in a little over 24h.

gzip -d -c c_lp_sm_c_lp_do_BAM_origi_gVCF_off_aafilled.vcf.gz > c_lp_sm_c_lp_do_BAM_origi_gVCF_off_aafilled.vcf #Get decompressed version. I ran md5sum for both the gzipped and the unzipped versions and there were no differences.

cd $V_PATH
grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_off_aafilled.vcf | wc -l #2502228

```

###D: Original BAMs, VCF via gVCFs.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Perform ancestral allele filling.

cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_origi_gVCF_on_aafilled.log
script c_lp_sm_c_lp_do_BAM_origi_gVCF_on_aafilled.log

export PERL5LIB=/opt/vcftools_0.1.13/perl/ #set required environmental variable
V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path

cat $V_PATH/c_lp_sm_c_lp_do_BAM_origi_gVCF_on.vcf | /opt/vcftools_0.1.13/perl/fill-aa -a /home/GRUPOS/grupolince/reference_genomes/lynx_rufus_genome/c_lr_zz_0001_recal1.fa.gz | bgzip -c > c_lp_sm_c_lp_do_BAM_origi_gVCF_on_aafilled.vcf.gz #I tried to run this first without bgzipping it, and it was increasingly slow. Each day it did around half the previous day. When the server crashed, I relaunched it adding the bgzip command and it finished in a little over 24h.

gzip -d -c c_lp_sm_c_lp_do_BAM_origi_gVCF_on_aafilled.vcf.gz > c_lp_sm_c_lp_do_BAM_origi_gVCF_on_aafilled.vcf #Get decompressed version. I ran md5sum for both the gzipped and the unzipped versions and there were no differences.

cd $V_PATH
grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_on_aafilled.vcf | wc -l #2517030

```

##Use VcfFilterJdk to polarize the annotated VCF.
###A: Recalibrated BAMs, VCF via gVCFs.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Polarize the AA-filled VCF based on the new INFO/AA column. Alleles will be switched whenever the ancestral allele matches the alternative one, and genotypes will be properly recoded as well. The following code was originally provided by Pierre Lindenbaum and modified by José Luis Castro.

cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized.log
script c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized.log

java -jar /opt/jvarkit/dist/vcffilterjdk.jar -e 'if(variant.getNAlleles()!=2 || !variant.hasAttribute("AA")) return true; 
final String aa = variant.getAttributeAsString("AA",""); 
if(!variant.getAlleles().get(1).getDisplayString().equalsIgnoreCase(aa)) return true; 
VariantContextBuilder vb=new VariantContextBuilder(variant); 

Allele oldalt = variant.getAlleles().get(1);
Allele oldref = variant.getAlleles().get(0); 
Allele ref= Allele.create(oldalt.getDisplayString(),true); 
Allele alt= Allele.create(oldref.getDisplayString(),false);

vb.alleles(Arrays.asList(ref,alt)); 

List genotypes= new ArrayList<>(); 
for(Genotype g: variant.getGenotypes()) 
  { 
  if(!g.isCalled()) 
  { genotypes.add(g); continue;} 
  GenotypeBuilder gb = new GenotypeBuilder(g); 
  List alleles = new ArrayList<>(); 
  for(Allele a:g.getAlleles()) { 
    if(a.equals(oldalt)) { a=ref;} 
    else if(a.equals(oldref)) { a=alt;} 
    alleles.add(a); 
    } 
  if(g.hasPL()) { 
    int pl[] = g.getPL(); 
    int pl2[] = new int[pl.length]; 
    for(int i=0;i< pl.length;i++) pl2[i]=pl[(pl.length-1)-i]; 
    gb.PL(pl2); 
    } 
  if(g.hasAD()) 
    { int ad[] = g.getAD(); 
    int ad2[] = new int[ad.length]; 
    for(int i=0;i< ad.length;i++) ad2[i]=ad[(ad.length-1)-i];
    gb.AD(ad2); 
  } 
  genotypes.add(gb.alleles(alleles).make()); 
  }

vb.attribute("AF",1.0d - Double.parseDouble(variant.getAttributeAsString("AF",""))); vb.attribute("AC",variant.getGenotypes().stream().flatMap(G->G.getAlleles().stream()).filter(A->A.equals(oldref)).count()); 
vb.genotypes(genotypes); 
return vb.make();' -o c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized.vcf c_lp_sm_c_lp_do_BAM_recal_gVCF_on_aafilled.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized.vcf | wc -l #

```

###B: Recalibrated BAMs, direct VCF.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Polarize the AA-filled VCF based on the new INFO/AA column. Alleles will be switched whenever the ancestral allele matches the alternative one, and genotypes will be properly recoded as well. The following code was originally provided by Pierre Lindenbaum and modified by José Luis Castro.

cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized.log
script c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized.log

java -jar /opt/jvarkit/dist/vcffilterjdk.jar -e 'if(variant.getNAlleles()!=2 || !variant.hasAttribute("AA")) return true; 
final String aa = variant.getAttributeAsString("AA",""); 
if(!variant.getAlleles().get(1).getDisplayString().equalsIgnoreCase(aa)) return true; 
VariantContextBuilder vb=new VariantContextBuilder(variant); 

Allele oldalt = variant.getAlleles().get(1);
Allele oldref = variant.getAlleles().get(0); 
Allele ref= Allele.create(oldalt.getDisplayString(),true); 
Allele alt= Allele.create(oldref.getDisplayString(),false);

vb.alleles(Arrays.asList(ref,alt)); 

List genotypes= new ArrayList<>(); 
for(Genotype g: variant.getGenotypes()) 
  { 
  if(!g.isCalled()) 
  { genotypes.add(g); continue;} 
  GenotypeBuilder gb = new GenotypeBuilder(g); 
  List alleles = new ArrayList<>(); 
  for(Allele a:g.getAlleles()) { 
    if(a.equals(oldalt)) { a=ref;} 
    else if(a.equals(oldref)) { a=alt;} 
    alleles.add(a); 
    } 
  if(g.hasPL()) { 
    int pl[] = g.getPL(); 
    int pl2[] = new int[pl.length]; 
    for(int i=0;i< pl.length;i++) pl2[i]=pl[(pl.length-1)-i]; 
    gb.PL(pl2); 
    } 
  if(g.hasAD()) 
    { int ad[] = g.getAD(); 
    int ad2[] = new int[ad.length]; 
    for(int i=0;i< ad.length;i++) ad2[i]=ad[(ad.length-1)-i];
    gb.AD(ad2); 
  } 
  genotypes.add(gb.alleles(alleles).make()); 
  }

vb.attribute("AF",1.0d - Double.parseDouble(variant.getAttributeAsString("AF",""))); vb.attribute("AC",variant.getGenotypes().stream().flatMap(G->G.getAlleles().stream()).filter(A->A.equals(oldref)).count()); 
vb.genotypes(genotypes); 
return vb.make();' -o c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized.vcf c_lp_sm_c_lp_do_BAM_recal_gVCF_off_aafilled.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized.vcf | wc -l #

```

###C: Original BAMs, direct VCF.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Polarize the AA-filled VCF based on the new INFO/AA column. Alleles will be switched whenever the ancestral allele matches the alternative one, and genotypes will be properly recoded as well. The following code was originally provided by Pierre Lindenbaum and modified by José Luis Castro.

cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized.log
script c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized.log

java -jar /opt/jvarkit/dist/vcffilterjdk.jar -e 'if(variant.getNAlleles()!=2 || !variant.hasAttribute("AA")) return true; 
final String aa = variant.getAttributeAsString("AA",""); 
if(!variant.getAlleles().get(1).getDisplayString().equalsIgnoreCase(aa)) return true; 
VariantContextBuilder vb=new VariantContextBuilder(variant); 

Allele oldalt = variant.getAlleles().get(1);
Allele oldref = variant.getAlleles().get(0); 
Allele ref= Allele.create(oldalt.getDisplayString(),true); 
Allele alt= Allele.create(oldref.getDisplayString(),false);

vb.alleles(Arrays.asList(ref,alt)); 

List genotypes= new ArrayList<>(); 
for(Genotype g: variant.getGenotypes()) 
  { 
  if(!g.isCalled()) 
  { genotypes.add(g); continue;} 
  GenotypeBuilder gb = new GenotypeBuilder(g); 
  List alleles = new ArrayList<>(); 
  for(Allele a:g.getAlleles()) { 
    if(a.equals(oldalt)) { a=ref;} 
    else if(a.equals(oldref)) { a=alt;} 
    alleles.add(a); 
    } 
  if(g.hasPL()) { 
    int pl[] = g.getPL(); 
    int pl2[] = new int[pl.length]; 
    for(int i=0;i< pl.length;i++) pl2[i]=pl[(pl.length-1)-i]; 
    gb.PL(pl2); 
    } 
  if(g.hasAD()) 
    { int ad[] = g.getAD(); 
    int ad2[] = new int[ad.length]; 
    for(int i=0;i< ad.length;i++) ad2[i]=ad[(ad.length-1)-i];
    gb.AD(ad2); 
  } 
  genotypes.add(gb.alleles(alleles).make()); 
  }

vb.attribute("AF",1.0d - Double.parseDouble(variant.getAttributeAsString("AF",""))); vb.attribute("AC",variant.getGenotypes().stream().flatMap(G->G.getAlleles().stream()).filter(A->A.equals(oldref)).count()); 
vb.genotypes(genotypes); 
return vb.make();' -o c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized.vcf c_lp_sm_c_lp_do_BAM_origi_gVCF_off_aafilled.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized.vcf | wc -l #

```

###D: Original BAMs, VCF via gVCFs.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Polarize the AA-filled VCF based on the new INFO/AA column. Alleles will be switched whenever the ancestral allele matches the alternative one, and genotypes will be properly recoded as well. The following code was originally provided by Pierre Lindenbaum and modified by José Luis Castro.

cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized.log
script c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized.log

java -jar /opt/jvarkit/dist/vcffilterjdk.jar -e 'if(variant.getNAlleles()!=2 || !variant.hasAttribute("AA")) return true; 
final String aa = variant.getAttributeAsString("AA",""); 
if(!variant.getAlleles().get(1).getDisplayString().equalsIgnoreCase(aa)) return true; 
VariantContextBuilder vb=new VariantContextBuilder(variant); 

Allele oldalt = variant.getAlleles().get(1);
Allele oldref = variant.getAlleles().get(0); 
Allele ref= Allele.create(oldalt.getDisplayString(),true); 
Allele alt= Allele.create(oldref.getDisplayString(),false);

vb.alleles(Arrays.asList(ref,alt)); 

List genotypes= new ArrayList<>(); 
for(Genotype g: variant.getGenotypes()) 
  { 
  if(!g.isCalled()) 
  { genotypes.add(g); continue;} 
  GenotypeBuilder gb = new GenotypeBuilder(g); 
  List alleles = new ArrayList<>(); 
  for(Allele a:g.getAlleles()) { 
    if(a.equals(oldalt)) { a=ref;} 
    else if(a.equals(oldref)) { a=alt;} 
    alleles.add(a); 
    } 
  if(g.hasPL()) { 
    int pl[] = g.getPL(); 
    int pl2[] = new int[pl.length]; 
    for(int i=0;i< pl.length;i++) pl2[i]=pl[(pl.length-1)-i]; 
    gb.PL(pl2); 
    } 
  if(g.hasAD()) 
    { int ad[] = g.getAD(); 
    int ad2[] = new int[ad.length]; 
    for(int i=0;i< ad.length;i++) ad2[i]=ad[(ad.length-1)-i];
    gb.AD(ad2); 
  } 
  genotypes.add(gb.alleles(alleles).make()); 
  }

vb.attribute("AF",1.0d - Double.parseDouble(variant.getAttributeAsString("AF",""))); vb.attribute("AC",variant.getGenotypes().stream().flatMap(G->G.getAlleles().stream()).filter(A->A.equals(oldref)).count()); 
vb.genotypes(genotypes); 
return vb.make();' -o c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized.vcf c_lp_sm_c_lp_do_BAM_origi_gVCF_on_aafilled.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized.vcf | wc -l #

```

#2: Set up SnpEff.
##Search for the Lynx pardinus database. 
Search for the Lynx pardinus assembly database in the program's pre-built database. As of June the 6th, 2017, the Lynx pardinus genome isn't included in the snpEff database. A second option would be building our own Lynx pardinus database.

```{r Set up SnpEff, eval=FALSE, engine='bash'}

java -jar /opt/snpEff/snpEff.jar databases | grep -i pardinus

```

##Build the Lynx pardinus genome database.
In the end we opt to build our own database since we don't know when they will get themselves to add it. This step should be omitted if the desired database was found in the previous step. In the end it's best to use the Lynx rufus genome as reference if the VCF is polarized based on Lynx rufus, else the polarized SNPs are wrongly annotated.

###Add entry to the config file

```{r Set up SnpEff, eval=FALSE, engine='bash'}

#Originally the config was just in the software folder and I didn't have writing permission. If this is the only config file available, writing permission is required, and when annotating later on, the file should be called using the -c command followed by the path to the file.
#However, in my case I believe the tech group created a copy of the file in my folder after I sent them an e-mail, and this is the one that I was able to edit.

cd /home/dkleinman/
mv snpEff.config $C_PATH #I move the config file that appeared in my folder to a subfolder that I created for snpEff
vi snpEff.config  #initiate the editing process

#Following the manual, I added the following two lines (use :o to start editing -watch out for the current line- and :wq to save and exit):

# Lynx_pardinus
LYPA.23.genome : Iberian lynx #from now on, LYPA.23 is the code for the Lynx pardinus reference genome (in snpEff)

# Lynx_pardinus, detailed annotation (obsolete)
LYPA.23b.genome : Iberian lynx #LYPA.23b is the code for the highly detailed annotation of the Lynx pardinus reference genome (in snpEff)

#In the end it's best to use the Lynx rufus genome as reference if the VCF is polarized based on Lynx rufus, else the polarized SNPs are wrongly annotated.

```

###Create directory and move files

```{r Set up SnpEff, eval=FALSE, engine='bash'}

#First for the regular annotation:
mkdir $S_PATH/data/LYPA.23 #create a directory inside the software's dependencies whose name matches the code
cd $S_PATH/data/LYPA.23

scp /GRUPOS/grupolince/Lyp_annotation_Apr14_final/LYPA23C.all.fix.nr.gff3 $S_PATH/data/LYPA.23/ #copy the annotation file (can be gff or gtf) to the newly created directory. This gff file includes CDS, introns, exons and genes, so it's very basic. A more complex version that Maria created which includes lncRNAs, etc., will be considered as custom annotation.
mv LYPA23C.all.fix.nr.gff3 genes.gff #rename the file as the tutorial indicates

mkdir $S_PATH/data/genomes #create a directory inside the software's dependencies called genomes
cd $S_PATH/data/genomes
scp /home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa $S_PATH/data/genomes #copy the reference genome fasta to the new genomes directory
mv lp23.fa LYPA.23.fa #rename the file so that it matches the code


#In the end this won't be used. The detailed (custom) annotation will be intersected using a bed and the -interval command.
#Second, for the detailed annotation:
mkdir $C_PATH/data/LYPA.23b #create a directory inside the software's dependencies whose name matches the code
cd $C_PATH/data/LYPA.23b

scp /GRUPOS/grupolince/Lyp_annotation_Apr14_final/LYPA23C.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.UCNE.intergenic.nr.gff3 $C_PATH/data/LYPA.23b/ #copy the annotation file (can be gff or gtf) to the newly created directory. This gff file is very detailed and includes CDS, introns, exons, genes, and many more.
mv LYPA23C.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.UCNE.intergenic.nr.gff3 genes.gff #rename the file as the tutorial indicates

cd $C_PATH/data/genomes
scp LYPA.23.fa LYPA.23b.fa #copy the reference genome and rename it so that it also matches the detailed annotation entry

```

###Build the database

```{r Set up SnpEff, eval=FALSE, engine='bash'}

cd $C_PATH
screen -S build_snpEff_db #open a dettachable screen in case the database building takes too long
script build_snpEff_db.txt #initiate the log file

S_PATH=/opt/snpEff #redefine the variable, since we're inside a script
C_PATH=/home/dkleinman/datos/snpEff #redefine the variable, since we're inside a script

cd $S_PATH
java -jar snpEff.jar build -gff3 -v LYPA.23 -c $C_PATH/snpEff.config -dataDir $C_PATH/data #build the database. Use the -gff3 command for gff files and -gtf22 for gtf files. Use -v for verbose (expanded information on the processes and the warnings/errors that may appear). Use -c to indicate the path to my own config file. Then use -dataDir to override the data directory from the config file (by default the software thinks that the data folder with the genome and the genes files is located where config is, so it's necessary to give it the correct path).

ctrl + D #terminate the script
ctrl + D #terminate the screen

#The following is obsolete since I fixed the original code.
scp -r $S_PATH/data $C_PATH #afterwards I realize anyone can access the data folder so I copy it to my own folder and then I remove the stuff I created inside the original data folder
cd $S_PATH/data
rm -r LYPA.23/
rm -r genomes/

```

### Tutorial annotation
Annotate one of the examples that comes with the software

```{r Tutorial annotation, eval=FALSE, engine='bash'}

java -Xmx16g -jar $S_PATH/snpEff.jar GRCh37.75 -s $O_PATH/toys/test.chr22.ann $S_PATH/examples/test.chr22.vcf > $O_PATH/toys/test.chr22.ann.vcf

```

##Build the Lynx rufus genome database.
In the end we opt to build our own database since we don't know when they will get themselves to add it. This step should be omitted if the desired database was found in the previous step. Annotating against the Lynx rufus genome is the correct option if the VCF has been polarized based on that genome.

###Add entry to the config file

```{r Set up SnpEff, eval=FALSE, engine='bash'}

#Originally the config was just in the software folder and I didn't have writing permission. If this is the only config file available, writing permission is required, and when annotating later on, the file should be called using the -c command followed by the path to the file.
#However, in my case I believe the tech group created a copy of the file in my folder after I sent them an e-mail, and this is the one that I was able to edit.

cd /home/dkleinman/
mv snpEff.config $C_PATH #I move the config file that appeared in my folder to a subfolder that I created for snpEff
vi snpEff.config  #initiate the editing process

#Following the manual, I added the following two lines (use :o to start editing -watch out for the current line- and :wq to save and exit):

# Lynx_rufus
LYRU.23.genome : Bobcat #from now on, LYRU.23 is the code for the Lynx rufus c_lr_zz_0001_recal1.fa genome (in snpEff)

```

###Create directory and move files

```{r Set up SnpEff, eval=FALSE, engine='bash'}

#First for the regular annotation:
mkdir $C_PATH/data/LYRU.23 #create a directory inside the software's dependencies whose name matches the code
cd $C_PATH/data/LYRU.23

scp /GRUPOS/grupolince/Lyp_annotation_Apr14_final/LYPA23C.all.fix.nr.gff3 $C_PATH/data/LYRU.23/ #copy the annotation file (can be gff or gtf) to the newly created directory. This gff file includes CDS, introns, exons and genes, so it's very basic. A more complex version that Maria created which includes lncRNAs, etc., will be considered as custom annotation.
mv LYPA23C.all.fix.nr.gff3 genes.gff #rename the file as the tutorial indicates

mkdir $C_PATH/data/genomes #create a directory inside the software's dependencies called genomes
cd $C_PATH/data/genomes
scp /home/GRUPOS/grupolince/reference_genomes/lynx_rufus_genome/c_lr_zz_0001_recal1.fa $C_PATH/data/genomes #copy the reference genome fasta to the new genomes directory
mv c_lr_zz_0001_recal1.fa LYRU.23.fa #rename the file so that it matches the code

```

###Build the database

```{r Set up SnpEff, eval=FALSE, engine='bash'}

cd $C_PATH
screen -S build_LYRU_snpEff_db #open a dettachable screen in case the database building takes too long
script build_LYRU_snpEff_db.txt #initiate the log file

S_PATH=/opt/snpEff #redefine the variable, since we're inside a script
C_PATH=/home/dkleinman/datos/snpEff #redefine the variable, since we're inside a script

cd $S_PATH
java -jar snpEff.jar build -gff3 -v LYRU.23 -c $C_PATH/snpEff.config -dataDir $C_PATH/data #build the database. Use the -gff3 command for gff files and -gtf22 for gtf files. Use -v for verbose (expanded information on the processes and the warnings/errors that may appear). Use -c to indicate the path to my own config file. Then use -dataDir to override the data directory from the config file (by default the software thinks that the data folder with the genome and the genes files is located where config is, so it's necessary to give it the correct path).

ctrl + D #terminate the script
ctrl + D #terminate the screen

```

#3: Annotate using SnpEff.
##Create custom annotation bed file

```{r Annotate using SnpEff, eval=FALSE, engine='bash'}

#Create bed file with custom annotations based on the gff3 that María compiled.
cut -d$'\t' -f1,3,4,5 /GRUPOS/grupolince/Lyp_annotation_Apr14_final/LYPA23C.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.UCNE.intergenic.nr.gff3 | awk '{printf ("%s\t%s\t%s\t%s\n", $1, $3, $4, $2)}' > /home/dkleinman/datos/snpEff/data/LYPA23C.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.UCNE.intergenic.nr.bed

```

##Annotate the VCF with custom annotation
###A: Recalibrated BAMs, VCF via gVCFs.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Polarize the AA-filled VCF based on the new INFO/AA column. Alleles will be switched whenever the ancestral allele matches the alternative one, and genotypes will be properly recoded as well. The following code was originally provided by Pierre Lindenbaum and modified by José Luis Castro.

cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized.lr_ann.log
script c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized.lr_ann.log

S_PATH=/opt/snpEff #software path
C_PATH=/home/dkleinman/datos/snpEff #config file path
O_PATH=/home/dkleinman/datos/snpEff #output path
I_PATH=/home/GRUPOS/grupolince/immunocapture/prueba_highdiv #immunocapture path
V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path

cd $O_PATH #run this code from the directory where the config is located.
java -Xmx16g -jar $S_PATH/snpEff.jar LYRU.23 -v -s $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized.lr_ann.html -csvStats $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized.lr_ann.csv -interval $C_PATH/data/LYPA23C.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.UCNE.intergenic.nr.bed $V_PATH/c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized.vcf > $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized.lr_ann.vcf #run this code from the directory where the config is located.

cd $V_PATH/annotation
grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized.lr_ann.vcf | wc -l #2025478

```

###B: Recalibrated BAMs, direct VCF.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Polarize the AA-filled VCF based on the new INFO/AA column. Alleles will be switched whenever the ancestral allele matches the alternative one, and genotypes will be properly recoded as well. The following code was originally provided by Pierre Lindenbaum and modified by José Luis Castro.

cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized.lr_ann.log
script c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized.lr_ann.log

S_PATH=/opt/snpEff #software path
C_PATH=/home/dkleinman/datos/snpEff #config file path
O_PATH=/home/dkleinman/datos/snpEff #output path
I_PATH=/home/GRUPOS/grupolince/immunocapture/prueba_highdiv #immunocapture path
V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path

cd $O_PATH #run this code from the directory where the config is located.
java -Xmx16g -jar $S_PATH/snpEff.jar LYRU.23 -v -s $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized.lr_ann.html -csvStats $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized.lr_ann.csv -interval $C_PATH/data/LYPA23C.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.UCNE.intergenic.nr.bed $V_PATH/c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized.vcf > $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized.lr_ann.vcf #run this code from the directory where the config is located.

cd $V_PATH/annotation
grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized.lr_ann.vcf | wc -l #2030604

```

###C: Original BAMs, direct VCF.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Polarize the AA-filled VCF based on the new INFO/AA column. Alleles will be switched whenever the ancestral allele matches the alternative one, and genotypes will be properly recoded as well. The following code was originally provided by Pierre Lindenbaum and modified by José Luis Castro.

cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized.lr_ann.log
script c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized.lr_ann.log

S_PATH=/opt/snpEff #software path
C_PATH=/home/dkleinman/datos/snpEff #config file path
O_PATH=/home/dkleinman/datos/snpEff #output path
I_PATH=/home/GRUPOS/grupolince/immunocapture/prueba_highdiv #immunocapture path
V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path

cd $O_PATH #run this code from the directory where the config is located.
java -Xmx16g -jar $S_PATH/snpEff.jar LYRU.23 -v -s $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized.lr_ann.html -csvStats $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized.lr_ann.csv -interval $C_PATH/data/LYPA23C.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.UCNE.intergenic.nr.bed $V_PATH/c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized.vcf > $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized.lr_ann.vcf #run this code from the directory where the config is located.

cd $V_PATH/annotation
grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized.lr_ann.vcf | wc -l #2502228

```

###D: Original BAMs, VCF via gVCFs.

```{r Perform different callings, eval=FALSE, engine='bash'}

#Polarize the AA-filled VCF based on the new INFO/AA column. Alleles will be switched whenever the ancestral allele matches the alternative one, and genotypes will be properly recoded as well. The following code was originally provided by Pierre Lindenbaum and modified by José Luis Castro.

cd $V_PATH
screen -S c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized.lr_ann.log
script c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized.lr_ann.log

S_PATH=/opt/snpEff #software path
C_PATH=/home/dkleinman/datos/snpEff #config file path
O_PATH=/home/dkleinman/datos/snpEff #output path
I_PATH=/home/GRUPOS/grupolince/immunocapture/prueba_highdiv #immunocapture path
V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path

cd $O_PATH #run this code from the directory where the config is located.
java -Xmx16g -jar $S_PATH/snpEff.jar LYRU.23 -v -s $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized.lr_ann.html -csvStats $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized.lr_ann.csv -interval $C_PATH/data/LYPA23C.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.UCNE.intergenic.nr.bed $V_PATH/c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized.vcf > $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized.lr_ann.vcf #run this code from the directory where the config is located.

cd $V_PATH/annotation
grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized.lr_ann.vcf | wc -l #2517030

```

#4: Filter the annotated VCF. Subset the VCF files in order to keep only good quality biallelic SNP variants. 
##A: Recalibrated BAMs, VCF via gVCFs.

```{r Filter the annotated VCF, eval=FALSE, engine='bash'}

cd $V_PATH/annotation
screen -S c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized_filtered.lr_ann.log
script c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized_filtered.lr_ann.log

V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path
G_PATH=/GRUPOS/grupolince/lynx_genomes_5x/gVCFs #gVCFs path
REF=/home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa #path to reference genome (first eight scaffolds only)
GATK=/opt/GATK-3.7/GenomeAnalysisTK.jar #GATK software path
BCF=/opt/bcftools-1.6/bcftools #BCFtools software path


#Remove repetitive regions and those with low mappability:
bedtools subtract -a c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized.lr_ann.vcf -b /home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/repeats_and_lowcomp_no_redundant_mappability.k75_lessthan90.bed -header > c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized_filtered1.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized_filtered1.lr_ann.vcf | wc -l #


#During this step, all INDELs as well as all multiallelic and bad quality SNPs will be dropped from the respective VCFs.
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -Xms16g -Xmx32g -jar $GATK \
-T SelectVariants \
-selectType SNP \
-restrictAllelesTo BIALLELIC \
-R $REF \
-V c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized_filtered1.lr_ann.vcf \
-o c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized_filtered2.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized_filtered2.lr_ann.vcf | wc -l #


#Remove polarized ANC fixed variants (AF=0) or those that weren't polarizable (AA different from either REF or ALT):
$BCF view -e '(INFO/AA!=REF & INFO/AA!=ALT) | INFO/AF=0.00' c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized_filtered2.lr_ann.vcf > c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized_filtered3.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized_filtered3.lr_ann.vcf | wc -l #

#Apply GATK's recommended filters, and then some.     
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -Xms16g -Xmx32g -jar $GATK \
-T SelectVariants \
-select "QUAL >= 30 && QD >= 2.0 && FS <= 60.0 && MQ >= 40.0 && MQRankSum >= -12.5 && ReadPosRankSum >= -8.0" \
-R $REF \
-V c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized_filtered3.lr_ann.vcf \
-o c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized_filtered4.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized_filtered4.lr_ann.vcf | wc -l #409642

```

##B: Recalibrated BAMs, direct VCF.

```{r Filter the annotated VCF, eval=FALSE, engine='bash'}

cd $V_PATH/annotation
screen -S c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized_filtered.lr_ann.log
script c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized_filtered.lr_ann.log

V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path
G_PATH=/GRUPOS/grupolince/lynx_genomes_5x/gVCFs #gVCFs path
REF=/home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa #path to reference genome (first eight scaffolds only)
GATK=/opt/GATK-3.7/GenomeAnalysisTK.jar #GATK software path
BCF=/opt/bcftools-1.6/bcftools #BCFtools software path


#Remove repetitive regions and those with low mappability:
bedtools subtract -a c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized.lr_ann.vcf -b /home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/repeats_and_lowcomp_no_redundant_mappability.k75_lessthan90.bed -header > c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized_filtered1.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized_filtered1.lr_ann.vcf | wc -l #


#During this step, all INDELs as well as all multiallelic and bad quality SNPs will be dropped from the respective VCFs.
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -Xms16g -Xmx32g -jar $GATK \
-T SelectVariants \
-selectType SNP \
-restrictAllelesTo BIALLELIC \
-R $REF \
-V c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized_filtered1.lr_ann.vcf \
-o c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized_filtered2.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized_filtered2.lr_ann.vcf | wc -l #


#Remove polarized ANC fixed variants (AF=0) or those that weren't polarizable (AA different from either REF or ALT):
$BCF view -e '(INFO/AA!=REF & INFO/AA!=ALT) | INFO/AF=0.00' c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized_filtered2.lr_ann.vcf > c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized_filtered3.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized_filtered3.lr_ann.vcf | wc -l #

#Apply GATK's recommended filters, and then some.     
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -Xms16g -Xmx32g -jar $GATK \
-T SelectVariants \
-select "QUAL >= 30 && QD >= 2.0 && FS <= 60.0 && MQ >= 40.0 && MQRankSum >= -12.5 && ReadPosRankSum >= -8.0" \
-R $REF \
-V c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized_filtered3.lr_ann.vcf \
-o c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized_filtered4.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized_filtered4.lr_ann.vcf | wc -l #521858

```

##C: Original BAMs, direct VCF.

```{r Filter the annotated VCF, eval=FALSE, engine='bash'}

cd $V_PATH/annotation
screen -S c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized_filtered.lr_ann.log
script c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized_filtered.lr_ann.log

V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path
G_PATH=/GRUPOS/grupolince/lynx_genomes_5x/gVCFs #gVCFs path
REF=/home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa #path to reference genome (first eight scaffolds only)
GATK=/opt/GATK-3.7/GenomeAnalysisTK.jar #GATK software path
BCF=/opt/bcftools-1.6/bcftools #BCFtools software path


#Remove repetitive regions and those with low mappability:
bedtools subtract -a c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized.lr_ann.vcf -b /home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/repeats_and_lowcomp_no_redundant_mappability.k75_lessthan90.bed -header > c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized_filtered1.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized_filtered1.lr_ann.vcf | wc -l #


#During this step, all INDELs as well as all multiallelic and bad quality SNPs will be dropped from the respective VCFs.
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -Xms16g -Xmx32g -jar $GATK \
-T SelectVariants \
-selectType SNP \
-restrictAllelesTo BIALLELIC \
-R $REF \
-V c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized_filtered1.lr_ann.vcf \
-o c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized_filtered2.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized_filtered2.lr_ann.vcf | wc -l #


#Remove polarized ANC fixed variants (AF=0) or those that weren't polarizable (AA different from either REF or ALT):
$BCF view -e '(INFO/AA!=REF & INFO/AA!=ALT) | INFO/AF=0.00' c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized_filtered2.lr_ann.vcf > c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized_filtered3.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized_filtered3.lr_ann.vcf | wc -l #

#Apply GATK's recommended filters, and then some.     
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -Xms16g -Xmx32g -jar $GATK \
-T SelectVariants \
-select "QUAL >= 30 && QD >= 2.0 && FS <= 60.0 && MQ >= 40.0 && MQRankSum >= -12.5 && ReadPosRankSum >= -8.0" \
-R $REF \
-V c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized_filtered3.lr_ann.vcf \
-o c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized_filtered4.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized_filtered4.lr_ann.vcf | wc -l #640627

```

##D: Original BAMs, VCF via gVCFs.

```{r Filter the annotated VCF, eval=FALSE, engine='bash'}

cd $V_PATH/annotation
screen -S c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized_filtered.lr_ann.log
script c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized_filtered.lr_ann.log

V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path
G_PATH=/GRUPOS/grupolince/lynx_genomes_5x/gVCFs #gVCFs path
REF=/home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa #path to reference genome (first eight scaffolds only)
GATK=/opt/GATK-3.7/GenomeAnalysisTK.jar #GATK software path
BCF=/opt/bcftools-1.6/bcftools #BCFtools software path


#Remove repetitive regions and those with low mappability:
bedtools subtract -a c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized.lr_ann.vcf -b /home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/repeats_and_lowcomp_no_redundant_mappability.k75_lessthan90.bed -header > c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized_filtered1.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized_filtered1.lr_ann.vcf | wc -l #


#During this step, all INDELs as well as all multiallelic and bad quality SNPs will be dropped from the respective VCFs.
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -Xms16g -Xmx32g -jar $GATK \
-T SelectVariants \
-selectType SNP \
-restrictAllelesTo BIALLELIC \
-R $REF \
-V c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized_filtered1.lr_ann.vcf \
-o c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized_filtered2.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized_filtered2.lr_ann.vcf | wc -l #


#Remove polarized ANC fixed variants (AF=0) or those that weren't polarizable (AA different from either REF or ALT):
$BCF view -e '(INFO/AA!=REF & INFO/AA!=ALT) | INFO/AF=0.00' c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized_filtered2.lr_ann.vcf > c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized_filtered3.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized_filtered3.lr_ann.vcf | wc -l #

#Apply GATK's recommended filters, and then some.     
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -Xms16g -Xmx32g -jar $GATK \
-T SelectVariants \
-select "QUAL >= 30 && QD >= 2.0 && FS <= 60.0 && MQ >= 40.0 && MQRankSum >= -12.5 && ReadPosRankSum >= -8.0" \
-R $REF \
-V c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized_filtered3.lr_ann.vcf \
-o c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized_filtered4.lr_ann.vcf

grep -v '#' c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized_filtered4.lr_ann.vcf | wc -l #546864

```

#5: Split the VCFs into per individual VCFs. Generate a VCF for each individual.
##A: Recalibrated BAMs, VCF via gVCFs.

```{r Split the population VCFs into per individual VCFs, eval=FALSE, engine='bash'}

#Generate individual VCFs from the filtered VCFs:
cd $V_PATH/annotation
screen -S individuals_c_lp_sm_c_lp_do_BAM_recal_gVCF_on.lr_ann.log
script individuals_c_lp_sm_c_lp_do_BAM_recal_gVCF_on.lr_ann.log

V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path
G_PATH=/GRUPOS/grupolince/lynx_genomes_5x/gVCFs #gVCFs path
REF=/home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa #path to reference genome (first eight scaffolds only)
GATK=/opt/GATK-3.7/GenomeAnalysisTK.jar #GATK software path
BCF=/opt/bcftools-1.6/bcftools #BCFtools software path

cd $G_PATH
declare POP=$(ls c_lp_sm*.g.vcf.gz | cut -c1-7 | uniq)
for i in ${POP[@]}
  do
  echo "${i}"
  mkdir $V_PATH/annotation/"${i}"_individuals
  cd $V_PATH/annotation
  declare INDIVIDUALS=$($BCF query -l c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized_filtered4.lr_ann.vcf)
  for j in ${INDIVIDUALS[@]}
    do
    echo "${j}"
    ID=$(echo "${j}")
    java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -Xms16g -Xmx32g -jar $GATK \
    -T SelectVariants \
    -R $REF \
    -V $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_recal_gVCF_on_polarized_filtered4.lr_ann.vcf \
    -o $V_PATH/annotation/"${i}"_individuals/"${j}"_individual_c_lp_sm_c_lp_do_BAM_recal_gVCF_on.lr_ann.vcf \
    -env \
    -sn $ID
    done
  done

```

##B: Recalibrated BAMs, direct VCF.

```{r Split the population VCFs into per individual VCFs, eval=FALSE, engine='bash'}

#Generate individual VCFs from the filtered VCFs:
cd $V_PATH/annotation
screen -S individuals_c_lp_sm_c_lp_do_BAM_recal_gVCF_off.lr_ann.log
script individuals_c_lp_sm_c_lp_do_BAM_recal_gVCF_off.lr_ann.log

V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path
G_PATH=/GRUPOS/grupolince/lynx_genomes_5x/gVCFs #gVCFs path
REF=/home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa #path to reference genome (first eight scaffolds only)
GATK=/opt/GATK-3.7/GenomeAnalysisTK.jar #GATK software path
BCF=/opt/bcftools-1.6/bcftools #BCFtools software path

cd $G_PATH
declare POP=$(ls c_lp_sm*.g.vcf.gz | cut -c1-7 | uniq)
for i in ${POP[@]}
  do
  echo "${i}"
  mkdir $V_PATH/annotation/"${i}"_individuals
  cd $V_PATH/annotation
  declare INDIVIDUALS=$($BCF query -l c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized_filtered4.lr_ann.vcf)
  for j in ${INDIVIDUALS[@]}
    do
    echo "${j}"
    ID=$(echo "${j}")
    java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -Xms16g -Xmx32g -jar $GATK \
    -T SelectVariants \
    -R $REF \
    -V $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_recal_gVCF_off_polarized_filtered4.lr_ann.vcf \
    -o $V_PATH/annotation/"${i}"_individuals/"${j}"_individual_c_lp_sm_c_lp_do_BAM_recal_gVCF_off.lr_ann.vcf \
    -env \
    -sn $ID
    done
  done

```

##C: Original BAMs, direct VCF.

```{r Split the population VCFs into per individual VCFs, eval=FALSE, engine='bash'}

#Generate individual VCFs from the filtered VCFs:
cd $V_PATH/annotation
screen -S individuals_c_lp_sm_c_lp_do_BAM_origi_gVCF_off.lr_ann.log
script individuals_c_lp_sm_c_lp_do_BAM_origi_gVCF_off.lr_ann.log

V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path
G_PATH=/GRUPOS/grupolince/lynx_genomes_5x/gVCFs #gVCFs path
REF=/home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa #path to reference genome (first eight scaffolds only)
GATK=/opt/GATK-3.7/GenomeAnalysisTK.jar #GATK software path
BCF=/opt/bcftools-1.6/bcftools #BCFtools software path

cd $G_PATH
declare POP=$(ls c_lp_sm*.g.vcf.gz | cut -c1-7 | uniq)
for i in ${POP[@]}
  do
  echo "${i}"
  mkdir $V_PATH/annotation/"${i}"_individuals
  cd $V_PATH/annotation
  declare INDIVIDUALS=$($BCF query -l c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized_filtered4.lr_ann.vcf)
  for j in ${INDIVIDUALS[@]}
    do
    echo "${j}"
    ID=$(echo "${j}")
    java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -Xms16g -Xmx32g -jar $GATK \
    -T SelectVariants \
    -R $REF \
    -V $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_origi_gVCF_off_polarized_filtered4.lr_ann.vcf \
    -o $V_PATH/annotation/"${i}"_individuals/"${j}"_individual_c_lp_sm_c_lp_do_BAM_origi_gVCF_off.lr_ann.vcf \
    -env \
    -sn $ID
    done
  done

```

##D: Original BAMs, VCF via gVCFs.

```{r Split the population VCFs into per individual VCFs, eval=FALSE, engine='bash'}

#Generate individual VCFs from the filtered VCFs:
cd $V_PATH/annotation
screen -S individuals_c_lp_sm_c_lp_do_BAM_origi_gVCF_on.lr_ann.log
script individuals_c_lp_sm_c_lp_do_BAM_origi_gVCF_on.lr_ann.log

V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path
G_PATH=/GRUPOS/grupolince/lynx_genomes_5x/gVCFs #gVCFs path
REF=/home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa #path to reference genome (first eight scaffolds only)
GATK=/opt/GATK-3.7/GenomeAnalysisTK.jar #GATK software path
BCF=/opt/bcftools-1.6/bcftools #BCFtools software path

cd $G_PATH
declare POP=$(ls c_lp_sm*.g.vcf.gz | cut -c1-7 | uniq)
for i in ${POP[@]}
  do
  echo "${i}"
  mkdir $V_PATH/annotation/"${i}"_individuals
  cd $V_PATH/annotation
  declare INDIVIDUALS=$($BCF query -l c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized_filtered4.lr_ann.vcf)
  for j in ${INDIVIDUALS[@]}
    do
    echo "${j}"
    ID=$(echo "${j}")
    java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -Xms16g -Xmx32g -jar $GATK \
    -T SelectVariants \
    -R $REF \
    -V $V_PATH/annotation/c_lp_sm_c_lp_do_BAM_origi_gVCF_on_polarized_filtered4.lr_ann.vcf \
    -o $V_PATH/annotation/"${i}"_individuals/"${j}"_individual_c_lp_sm_c_lp_do_BAM_origi_gVCF_on.lr_ann.vcf \
    -env \
    -sn $ID
    done
  done

```

#6: Get individual-level annotation statistics.
##A: Recalibrated BAMs, VCF via gVCFs.

```{r Get annotation statistics, eval=FALSE, engine='bash'}

cd $V_PATH/annotation/
screen -S snpeff_individual_c_lp_sm_c_lp_do_BAM_recal_gVCF_on_summary.lr_ann.log
script snpeff_individual_c_lp_sm_c_lp_do_BAM_recal_gVCF_on_summary.lr_ann.log

V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path

rm snpeff_individual_c_lp_sm_c_lp_do_BAM_recal_gVCF_on_summary.lr_ann.txt
echo -e "species\tpopulation\tsample\ttotal_V\tintergenic_V\tintronic_V\tcoding\tsynonymous_V\tsynonymous_A\tmissense_V\tmissense_A\tnonsense_V\tnonsense_A\tmissense/synonymous_V\tmissense/synonymous_A" > snpeff_individual_c_lp_sm_c_lp_do_BAM_recal_gVCF_on_summary.lr_ann.txt
INDLIST=($(ls `find . -name '*_individual_c_lp_sm_c_lp_do_BAM_recal_gVCF_on.lr_ann.vcf' -print`))
for i in "${INDLIST[@]}"
  do
  echo "${i}"
  ind=$(echo "${i}" | awk -F'[/]' '{print $3}')
  echo "${ind}"
  SPECIES=$(echo "${ind}" | cut -c3-4)
  POPULATION=$(echo "${ind}" | cut -c6-7)
  SAMPLE=$(echo "${ind}" | cut -c9-12)
  TOTAL_V=$(grep -v '#' ${i} | wc -l)
  INTERGENIC_V=$(grep 'intergenic' ${i} | wc -l)
  INTRONIC_V=$(grep 'intron_variant' ${i} | wc -l)
  CODING_V=$(grep 'CDS' ${i} | wc -l)
  SYNONYMOUS_V=$(grep 'synonymous_variant' ${i} | wc -l)
  SYNONYMOUS_A=$(grep 'synonymous_variant' ${i} | cut -f8 | cut -d';' -f2 | cut -d'=' -f2 | paste -sd+ | bc)
  MISSENSE_V=$(grep 'missense_variant' ${i} | wc -l)
  MISSENSE_A=$(grep 'missense_variant' ${i} | cut -f8 | cut -d';' -f2 | cut -d'=' -f2 | paste -sd+ | bc)
  NONSENSE_V=$(grep -e 'lost' -e 'gained' ${i} | wc -l)
  NONSENSE_A=$(grep -e 'lost' -e 'gained' ${i} | cut -f8 | cut -d';' -f2 | cut -d'=' -f2 | paste -sd+ | bc)
  MISSENSE_SYNONYMOUS_V=$(echo "scale=3; $MISSENSE_V/$SYNONYMOUS_V" | bc)
  MISSENSE_SYNONYMOUS_A=$(echo "scale=3; $MISSENSE_A/$SYNONYMOUS_A" | bc)
  echo -e "$SPECIES\t$POPULATION\t$SAMPLE\t$TOTAL_V\t$INTERGENIC_V\t$INTRONIC_V\t$CODING_V\t$SYNONYMOUS_V\t$SYNONYMOUS_A\t$MISSENSE_V\t$MISSENSE_A\t$NONSENSE_V\t$NONSENSE_A\t$MISSENSE_SYNONYMOUS_V\t$MISSENSE_SYNONYMOUS_A" >> $V_PATH/annotation/snpeff_individual_c_lp_sm_c_lp_do_BAM_recal_gVCF_on_summary.lr_ann.txt
  done

```

##B: Recalibrated BAMs, direct VCF.

```{r Get annotation statistics, eval=FALSE, engine='bash'}

cd $V_PATH/annotation/
screen -S snpeff_individual_c_lp_sm_c_lp_do_BAM_recal_gVCF_off_summary.lr_ann.log
script snpeff_individual_c_lp_sm_c_lp_do_BAM_recal_gVCF_off_summary.lr_ann.log

V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path

rm snpeff_individual_c_lp_sm_c_lp_do_BAM_recal_gVCF_off_summary.lr_ann.txt
echo -e "species\tpopulation\tsample\ttotal_V\tintergenic_V\tintronic_V\tcoding\tsynonymous_V\tsynonymous_A\tmissense_V\tmissense_A\tnonsense_V\tnonsense_A\tmissense/synonymous_V\tmissense/synonymous_A" > snpeff_individual_c_lp_sm_c_lp_do_BAM_recal_gVCF_off_summary.lr_ann.txt
INDLIST=($(ls `find . -name '*_individual_c_lp_sm_c_lp_do_BAM_recal_gVCF_off.lr_ann.vcf' -print`))
for i in "${INDLIST[@]}"
  do
  echo "${i}"
  ind=$(echo "${i}" | awk -F'[/]' '{print $3}')
  echo "${ind}"
  SPECIES=$(echo "${ind}" | cut -c3-4)
  POPULATION=$(echo "${ind}" | cut -c6-7)
  SAMPLE=$(echo "${ind}" | cut -c9-12)
  TOTAL_V=$(grep -v '#' ${i} | wc -l)
  INTERGENIC_V=$(grep 'intergenic' ${i} | wc -l)
  INTRONIC_V=$(grep 'intron_variant' ${i} | wc -l)
  CODING_V=$(grep 'CDS' ${i} | wc -l)
  SYNONYMOUS_V=$(grep 'synonymous_variant' ${i} | wc -l)
  SYNONYMOUS_A=$(grep 'synonymous_variant' ${i} | cut -f8 | cut -d';' -f2 | cut -d'=' -f2 | paste -sd+ | bc)
  MISSENSE_V=$(grep 'missense_variant' ${i} | wc -l)
  MISSENSE_A=$(grep 'missense_variant' ${i} | cut -f8 | cut -d';' -f2 | cut -d'=' -f2 | paste -sd+ | bc)
  NONSENSE_V=$(grep -e 'lost' -e 'gained' ${i} | wc -l)
  NONSENSE_A=$(grep -e 'lost' -e 'gained' ${i} | cut -f8 | cut -d';' -f2 | cut -d'=' -f2 | paste -sd+ | bc)
  MISSENSE_SYNONYMOUS_V=$(echo "scale=3; $MISSENSE_V/$SYNONYMOUS_V" | bc)
  MISSENSE_SYNONYMOUS_A=$(echo "scale=3; $MISSENSE_A/$SYNONYMOUS_A" | bc)
  echo -e "$SPECIES\t$POPULATION\t$SAMPLE\t$TOTAL_V\t$INTERGENIC_V\t$INTRONIC_V\t$CODING_V\t$SYNONYMOUS_V\t$SYNONYMOUS_A\t$MISSENSE_V\t$MISSENSE_A\t$NONSENSE_V\t$NONSENSE_A\t$MISSENSE_SYNONYMOUS_V\t$MISSENSE_SYNONYMOUS_A" >> $V_PATH/annotation/snpeff_individual_c_lp_sm_c_lp_do_BAM_recal_gVCF_off_summary.lr_ann.txt
  done

```

##C: Original BAMs, direct VCF.

```{r Get annotation statistics, eval=FALSE, engine='bash'}

cd $V_PATH/annotation/
screen -S snpeff_individual_c_lp_sm_c_lp_do_BAM_origi_gVCF_off_summary.lr_ann.log
script snpeff_individual_c_lp_sm_c_lp_do_BAM_origi_gVCF_off_summary.lr_ann.log

V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path

rm snpeff_individual_c_lp_sm_c_lp_do_BAM_origi_gVCF_off_summary.lr_ann.txt
echo -e "species\tpopulation\tsample\ttotal_V\tintergenic_V\tintronic_V\tcoding\tsynonymous_V\tsynonymous_A\tmissense_V\tmissense_A\tnonsense_V\tnonsense_A\tmissense/synonymous_V\tmissense/synonymous_A" > snpeff_individual_c_lp_sm_c_lp_do_BAM_origi_gVCF_off_summary.lr_ann.txt
INDLIST=($(ls `find . -name '*_individual_c_lp_sm_c_lp_do_BAM_origi_gVCF_off.lr_ann.vcf' -print`))
for i in "${INDLIST[@]}"
  do
  echo "${i}"
  ind=$(echo "${i}" | awk -F'[/]' '{print $3}')
  echo "${ind}"
  SPECIES=$(echo "${ind}" | cut -c3-4)
  POPULATION=$(echo "${ind}" | cut -c6-7)
  SAMPLE=$(echo "${ind}" | cut -c9-12)
  TOTAL_V=$(grep -v '#' ${i} | wc -l)
  INTERGENIC_V=$(grep 'intergenic' ${i} | wc -l)
  INTRONIC_V=$(grep 'intron_variant' ${i} | wc -l)
  CODING_V=$(grep 'CDS' ${i} | wc -l)
  SYNONYMOUS_V=$(grep 'synonymous_variant' ${i} | wc -l)
  SYNONYMOUS_A=$(grep 'synonymous_variant' ${i} | cut -f8 | cut -d';' -f2 | cut -d'=' -f2 | paste -sd+ | bc)
  MISSENSE_V=$(grep 'missense_variant' ${i} | wc -l)
  MISSENSE_A=$(grep 'missense_variant' ${i} | cut -f8 | cut -d';' -f2 | cut -d'=' -f2 | paste -sd+ | bc)
  NONSENSE_V=$(grep -e 'lost' -e 'gained' ${i} | wc -l)
  NONSENSE_A=$(grep -e 'lost' -e 'gained' ${i} | cut -f8 | cut -d';' -f2 | cut -d'=' -f2 | paste -sd+ | bc)
  MISSENSE_SYNONYMOUS_V=$(echo "scale=3; $MISSENSE_V/$SYNONYMOUS_V" | bc)
  MISSENSE_SYNONYMOUS_A=$(echo "scale=3; $MISSENSE_A/$SYNONYMOUS_A" | bc)
  echo -e "$SPECIES\t$POPULATION\t$SAMPLE\t$TOTAL_V\t$INTERGENIC_V\t$INTRONIC_V\t$CODING_V\t$SYNONYMOUS_V\t$SYNONYMOUS_A\t$MISSENSE_V\t$MISSENSE_A\t$NONSENSE_V\t$NONSENSE_A\t$MISSENSE_SYNONYMOUS_V\t$MISSENSE_SYNONYMOUS_A" >> $V_PATH/annotation/snpeff_individual_c_lp_sm_c_lp_do_BAM_origi_gVCF_off_summary.lr_ann.txt
  done

```

##D: Original BAMs, VCF via gVCFs.

```{r Get annotation statistics, eval=FALSE, engine='bash'}

cd $V_PATH/annotation/
screen -S snpeff_individual_c_lp_sm_c_lp_do_BAM_origi_gVCF_on_summary.lr_ann.log
script snpeff_individual_c_lp_sm_c_lp_do_BAM_origi_gVCF_on_summary.lr_ann.log

V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/BQSR_gVCFs_tests #VCFs path

rm snpeff_individual_c_lp_sm_c_lp_do_BAM_origi_gVCF_on_summary.lr_ann.txt
echo -e "species\tpopulation\tsample\ttotal_V\tintergenic_V\tintronic_V\tcoding\tsynonymous_V\tsynonymous_A\tmissense_V\tmissense_A\tnonsense_V\tnonsense_A\tmissense/synonymous_V\tmissense/synonymous_A" > snpeff_individual_c_lp_sm_c_lp_do_BAM_origi_gVCF_on_summary.lr_ann.txt
INDLIST=($(ls `find . -name '*_individual_c_lp_sm_c_lp_do_BAM_origi_gVCF_on.lr_ann.vcf' -print`))
for i in "${INDLIST[@]}"
  do
  echo "${i}"
  ind=$(echo "${i}" | awk -F'[/]' '{print $3}')
  echo "${ind}"
  SPECIES=$(echo "${ind}" | cut -c3-4)
  POPULATION=$(echo "${ind}" | cut -c6-7)
  SAMPLE=$(echo "${ind}" | cut -c9-12)
  TOTAL_V=$(grep -v '#' ${i} | wc -l)
  INTERGENIC_V=$(grep 'intergenic' ${i} | wc -l)
  INTRONIC_V=$(grep 'intron_variant' ${i} | wc -l)
  CODING_V=$(grep 'CDS' ${i} | wc -l)
  SYNONYMOUS_V=$(grep 'synonymous_variant' ${i} | wc -l)
  SYNONYMOUS_A=$(grep 'synonymous_variant' ${i} | cut -f8 | cut -d';' -f2 | cut -d'=' -f2 | paste -sd+ | bc)
  MISSENSE_V=$(grep 'missense_variant' ${i} | wc -l)
  MISSENSE_A=$(grep 'missense_variant' ${i} | cut -f8 | cut -d';' -f2 | cut -d'=' -f2 | paste -sd+ | bc)
  NONSENSE_V=$(grep -e 'lost' -e 'gained' ${i} | wc -l)
  NONSENSE_A=$(grep -e 'lost' -e 'gained' ${i} | cut -f8 | cut -d';' -f2 | cut -d'=' -f2 | paste -sd+ | bc)
  MISSENSE_SYNONYMOUS_V=$(echo "scale=3; $MISSENSE_V/$SYNONYMOUS_V" | bc)
  MISSENSE_SYNONYMOUS_A=$(echo "scale=3; $MISSENSE_A/$SYNONYMOUS_A" | bc)
  echo -e "$SPECIES\t$POPULATION\t$SAMPLE\t$TOTAL_V\t$INTERGENIC_V\t$INTRONIC_V\t$CODING_V\t$SYNONYMOUS_V\t$SYNONYMOUS_A\t$MISSENSE_V\t$MISSENSE_A\t$NONSENSE_V\t$NONSENSE_A\t$MISSENSE_SYNONYMOUS_V\t$MISSENSE_SYNONYMOUS_A" >> $V_PATH/annotation/snpeff_individual_c_lp_sm_c_lp_do_BAM_origi_gVCF_on_summary.lr_ann.txt
  done

```

##Draw annotation statistics.

```{r Get annotation statistics}

library(readr)
library(dplyr)
library(tidyr)
library(ggplot2)
library(RColorBrewer)

#lp based annotation:

wd <- file.path("/Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/snpeff_summary_ratios")
setwd(wd)
files <- grep(grep(list.files(file.path("/Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/snpeff_summary_ratios"), pattern = "lp_ann", full.names=T), pattern='test_allele_counts', inv=T, value=T),pattern='between', value=T)
files
perpop_between_statistics <- data_frame("population"=character(0),"category"=character(0),"value"=numeric(0),"dataset"=character(0))
for (f in c(2,1)) {
  current_file <- read_tsv(files[f])
  current_file <- current_file %>% mutate("I_ratio"=intronic_V/intergenic_V,"S_ratio*15"=15*synonymous_V/intergenic_V,"NS_ratio*15"=15*missense_V/intergenic_V,"LOF_ratio*2000"=2000*nonsense_V/intergenic_V,"NS/S_v"=missense_V/synonymous_V,"NS/S_a"=missense_A/synonymous_A,"LOF/S_v*50"=50*nonsense_V/synonymous_V,"LOF/S_a*50"=50*nonsense_A/synonymous_A,dataset=unlist(strsplit(files[f],"/|_|\\."))[length(unlist(strsplit(files[f],"/|_|\\.")))-3]) %>% select(2,c(16:24))
  current_file
  current_file_tidy <- current_file %>% gather(category,value,-population,-dataset) %>% select(1,3,4,2)
  current_file_tidy
  perpop_between_statistics <- rbind(perpop_between_statistics,current_file_tidy)
}
perpop_between_statistics$population <- as.factor(perpop_between_statistics$population)
perpop_between_statistics$population = factor(perpop_between_statistics$population,levels(perpop_between_statistics$population)[c(2:5,1)])
perpop_between_statistics$category <- as.factor(perpop_between_statistics$category)
perpop_between_statistics$category = factor(perpop_between_statistics$category,levels(perpop_between_statistics$category)[c(1,8,5,2,7,6,4,3)])
perpop_between_statistics$dataset <- as.factor(perpop_between_statistics$dataset)
perpop_between_statistics$dataset = factor(perpop_between_statistics$dataset,levels(perpop_between_statistics$dataset)[c(2,1)])
perpop_between_statistics

ggplot_perpop_between <- ggplot(data=perpop_between_statistics, aes(x=category,y=value)) +
  geom_point(aes(colour = population)) + 
  scale_color_manual(values=c(brewer.pal(12,"Paired")[1], brewer.pal(12,"Paired")[2], brewer.pal(12,"Paired")[4], brewer.pal(8,"Greys")[5],brewer.pal(8,"Greys")[8])) +
  facet_grid(. ~ dataset) +
  ggtitle("Ratios per population (N=8) with pardinus based annotation") +
  ylim(0.0,1.0) +
  theme_bw() +
  theme(text=element_text(size=12,face="bold"),
        rect=element_rect(size=1),
        axis.line=element_line(colour="black"),
        axis.title=element_text(size=16),
        axis.text.x=element_text(angle=90,hjust=1,vjust=0.5),
        #axis.text.y=element_text(size=24,colour="black",margin=margin(t=0.5,unit="cm")),
        #axis.title.y=element_text(size=30,margin=margin(r=0.5,unit="cm")),
        panel.background=element_blank(),
        panel.border=element_rect(colour="black"),
        #panel.grid=element_blank(),
        #panel.grid.major=element_line(colour="grey", linetype="dashed", size=0.4),
        plot.margin=unit(c(0.5,1,0.5,0.5),"cm"),
        #plot.title=element_text(size=36, face="bold", margin=margin(b=0.5, unit="cm")),
        legend.background=element_rect(linetype="solid", colour="black", size=.5),
        #legend.justification=c(0,0),
        legend.key=element_rect(colour="white"),
        #legend.key.size=unit(1.3,"cm"),
        #legend.position=c(0.92,0.86),
        legend.title=element_blank()
  )
ggplot_perpop_between
ggsave("perpop_counts_ratios.lp_ann.pdf", width=30, height=15, units="cm", device="pdf", path="/Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/snpeff_summary_ratios")

#lr based annotation filtered 1:

wd <- file.path("/Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/snpeff_summary_ratios")
setwd(wd)
files <- grep(grep(list.files(file.path("/Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/snpeff_summary_ratios"), pattern = "summary_w.*lr_ann", full.names=T), pattern='test_allele_counts', inv=T, value=T),pattern='between', value=T)
files
perpop_between_statistics <- data_frame("population"=character(0),"category"=character(0),"value"=numeric(0),"dataset"=character(0))
for (f in c(1,2)) {
  current_file <- read_tsv(files[f])
  current_file <- current_file %>% mutate("I_ratio"=intronic_V/intergenic_V,"S_ratio*15"=15*synonymous_V/intergenic_V,"NS_ratio*15"=15*missense_V/intergenic_V,"LOF_ratio*2000"=2000*nonsense_V/intergenic_V,"NS/S_v"=missense_V/synonymous_V,"NS/S_a"=missense_A/synonymous_A,"LOF/S_v*50"=50*nonsense_V/synonymous_V,"LOF/S_a*50"=50*nonsense_A/synonymous_A,dataset=unlist(strsplit(files[f],"/|_|\\."))[length(unlist(strsplit(files[f],"/|_|\\.")))-3]) %>% select(2,c(16:24))
  current_file
  current_file_tidy <- current_file %>% gather(category,value,-population,-dataset) %>% select(1,3,4,2)
  current_file_tidy
  perpop_between_statistics <- rbind(perpop_between_statistics,current_file_tidy)
}
perpop_between_statistics$population <- as.factor(perpop_between_statistics$population)
perpop_between_statistics$population = factor(perpop_between_statistics$population,levels(perpop_between_statistics$population)[c(2:5,1)])
perpop_between_statistics$category <- as.factor(perpop_between_statistics$category)
perpop_between_statistics$category = factor(perpop_between_statistics$category,levels(perpop_between_statistics$category)[c(1,8,5,2,7,6,4,3)])
perpop_between_statistics$dataset <- as.factor(perpop_between_statistics$dataset)
perpop_between_statistics$dataset = factor(perpop_between_statistics$dataset,levels(perpop_between_statistics$dataset)[c(1,2)])
perpop_between_statistics

ggplot_perpop_between <- ggplot(data=perpop_between_statistics, aes(x=category,y=value)) +
  geom_point(aes(colour = population)) + 
  scale_color_manual(values=c(brewer.pal(12,"Paired")[1], brewer.pal(12,"Paired")[2], brewer.pal(12,"Paired")[4], brewer.pal(8,"Greys")[5],brewer.pal(8,"Greys")[8])) +
  facet_grid(. ~ dataset) +
  ggtitle("Ratios per population (N=8) with rufus based annotation") +
  ylim(0.0,1.0) +
  theme_bw() +
  theme(text=element_text(size=12,face="bold"),
        rect=element_rect(size=1),
        axis.line=element_line(colour="black"),
        axis.title=element_text(size=16),
        axis.text.x=element_text(angle=90,hjust=1,vjust=0.5),
        #axis.text.y=element_text(size=24,colour="black",margin=margin(t=0.5,unit="cm")),
        #axis.title.y=element_text(size=30,margin=margin(r=0.5,unit="cm")),
        panel.background=element_blank(),
        panel.border=element_rect(colour="black"),
        #panel.grid=element_blank(),
        #panel.grid.major=element_line(colour="grey", linetype="dashed", size=0.4),
        plot.margin=unit(c(0.5,1,0.5,0.5),"cm"),
        #plot.title=element_text(size=36, face="bold", margin=margin(b=0.5, unit="cm")),
        legend.background=element_rect(linetype="solid", colour="black", size=.5),
        #legend.justification=c(0,0),
        legend.key=element_rect(colour="white"),
        #legend.key.size=unit(1.3,"cm"),
        #legend.position=c(0.92,0.86),
        legend.title=element_blank()
  )
ggplot_perpop_between
ggsave("perpop_counts_ratios.lr_ann.pdf", width=30, height=15, units="cm", device="pdf", path="/Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/snpeff_summary_ratios")

#lr based annotation filtered 2:

wd <- file.path("/Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/snpeff_summary_ratios")
setwd(wd)
files <- grep(grep(list.files(file.path("/Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/snpeff_summary_ratios"), pattern = "filtered2.*lr_ann", full.names=T), pattern='test_allele_counts', inv=T, value=T),pattern='between', value=T)
files
perpop_between_statistics <- data_frame("population"=character(0),"category"=character(0),"value"=numeric(0),"dataset"=character(0))
for (f in c(1,2)) {
  current_file <- read_tsv(files[f])
  current_file <- current_file %>% mutate("I_ratio"=intronic_V/intergenic_V,"S_ratio*15"=15*synonymous_V/intergenic_V,"NS_ratio*15"=15*missense_V/intergenic_V,"LOF_ratio*2000"=2000*nonsense_V/intergenic_V,"NS/S_v"=missense_V/synonymous_V,"NS/S_a"=missense_A/synonymous_A,"LOF/S_v*50"=50*nonsense_V/synonymous_V,"LOF/S_a*50"=50*nonsense_A/synonymous_A,dataset=unlist(strsplit(files[f],"/|_|\\."))[length(unlist(strsplit(files[f],"/|_|\\.")))-3]) %>% select(2,c(16:24))
  current_file
  current_file_tidy <- current_file %>% gather(category,value,-population,-dataset) %>% select(1,3,4,2)
  current_file_tidy
  perpop_between_statistics <- rbind(perpop_between_statistics,current_file_tidy)
}
perpop_between_statistics$population <- as.factor(perpop_between_statistics$population)
perpop_between_statistics$population = factor(perpop_between_statistics$population,levels(perpop_between_statistics$population)[c(2:5,1)])
perpop_between_statistics$category <- as.factor(perpop_between_statistics$category)
perpop_between_statistics$category = factor(perpop_between_statistics$category,levels(perpop_between_statistics$category)[c(1,8,5,2,7,6,4,3)])
perpop_between_statistics$dataset <- as.factor(perpop_between_statistics$dataset)
perpop_between_statistics$dataset = factor(perpop_between_statistics$dataset,levels(perpop_between_statistics$dataset)[c(1,2)])
perpop_between_statistics

ggplot_perpop_between <- ggplot(data=perpop_between_statistics, aes(x=category,y=value)) +
  geom_point(aes(colour = population)) + 
  scale_color_manual(values=c(brewer.pal(12,"Paired")[1], brewer.pal(12,"Paired")[2], brewer.pal(12,"Paired")[4], brewer.pal(8,"Greys")[5],brewer.pal(8,"Greys")[8])) +
  facet_grid(. ~ dataset) +
  ggtitle("Ratios per population (N=8) with rufus based annotation and strict missingness") +
  ylim(0.0,1.0) +
  theme_bw() +
  theme(text=element_text(size=12,face="bold"),
        rect=element_rect(size=1),
        axis.line=element_line(colour="black"),
        axis.title=element_text(size=16),
        axis.text.x=element_text(angle=90,hjust=1,vjust=0.5),
        #axis.text.y=element_text(size=24,colour="black",margin=margin(t=0.5,unit="cm")),
        #axis.title.y=element_text(size=30,margin=margin(r=0.5,unit="cm")),
        panel.background=element_blank(),
        panel.border=element_rect(colour="black"),
        #panel.grid=element_blank(),
        #panel.grid.major=element_line(colour="grey", linetype="dashed", size=0.4),
        plot.margin=unit(c(0.5,1,0.5,0.5),"cm"),
        #plot.title=element_text(size=36, face="bold", margin=margin(b=0.5, unit="cm")),
        legend.background=element_rect(linetype="solid", colour="black", size=.5),
        #legend.justification=c(0,0),
        legend.key=element_rect(colour="white"),
        #legend.key.size=unit(1.3,"cm"),
        #legend.position=c(0.92,0.86),
        legend.title=element_blank()
  )
ggplot_perpop_between
ggsave("perpop_counts_ratios_filtered2.lr_ann.pdf", width=30, height=15, units="cm", device="pdf", path="/Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/snpeff_summary_ratios")


```

##Obtain frequency distribution.

```{r Get annotation statistics, eval=FALSE, engine='bash'}

#with1: for each population (minimum subsample, with1 version) extract allele frequency from all SNPs in each class of interest, and save them in a file:

cd $V_PATH/annotation/
screen -S features_frequency_distribution_with1.lr_ann.log
script features_frequency_distribution_with1.lr_ann.log

rm $V_PATH/annotation/features_frequency_distribution_with1.lr_ann.txt
POPLIST=($(ls -d c_{lp_sm*,lp_do*,ll_ki*,ll_po*,ll_no*}perpop))
for pop in "${POPLIST[@]}"
  do
  echo "${pop}"
  cd $V_PATH/annotation/"${pop}"/
  SPECIES=$(echo "${pop}" | cut -c3-4)
  POPULATION=$(echo "${pop}" | cut -c6-7)
  if [ -e ${pop}_minimum_subsample_with1.lr_ann.vcf ]; then
    echo "Minimum "$POPULATION" subsample available"
    FILE=${pop}_minimum_subsample_with1.lr_ann.vcf
  elif [ -e ${pop}_random_subsample_with1.lr_ann.vcf ]; then
    echo "Random "$POPULATION" subsample available"
    FILE=${pop}_random_subsample_with1.lr_ann.vcf
  else
    echo "Original "$POPULATION" available"
    FILE=${pop}_with1.lr_ann.vcf
  fi
  declare -a FEATURES=("intergenic" "intron_variant" "synonymous_variant" "missense_variant")
  for feat in "${FEATURES[@]}"
    do
    echo "${feat}"
    grep "${feat}" $FILE | cut -f8 | cut -d';' -f3 | cut -d'=' -f2 | awk -v pop="$POPULATION" -v feat="${feat}" '{print $1" "pop" "feat}' >> $V_PATH/annotation/features_frequency_distribution_with1.lr_ann.txt
    done
    cd $V_PATH/annotation/
  done

scp dkleinman@genomics-b.ebd.csic.es:/home/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/annotation/features_frequency_distribution_with1.lr_ann.txt /Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/features_frequency_distribution/


#wout1: for each population (minimum subsample, wout1 version) extract allele frequency from all SNPs in each class of interest, and save them in a file:

cd $V_PATH/annotation/
screen -S features_frequency_distribution_wout1.lr_ann.log
script features_frequency_distribution_wout1.lr_ann.log

rm $V_PATH/annotation/features_frequency_distribution_wout1.lr_ann.txt
POPLIST=($(ls -d c_{lp_sm*,lp_do*,ll_ki*,ll_po*,ll_no*}perpop))
for pop in "${POPLIST[@]}"
  do
  echo "${pop}"
  cd $V_PATH/annotation/"${pop}"/
  SPECIES=$(echo "${pop}" | cut -c3-4)
  POPULATION=$(echo "${pop}" | cut -c6-7)
  if [ -e ${pop}_minimum_subsample_wout1.lr_ann.vcf ]; then
    echo "Minimum "$POPULATION" subsample available"
    FILE=${pop}_minimum_subsample_wout1.lr_ann.vcf
  elif [ -e ${pop}_random_subsample_wout1.lr_ann.vcf ]; then
    echo "Random "$POPULATION" subsample available"
    FILE=${pop}_random_subsample_wout1.lr_ann.vcf
  else
    echo "Original "$POPULATION" available"
    FILE=${pop}_wout1.lr_ann.vcf
  fi
  declare -a FEATURES=("intergenic" "intron_variant" "synonymous_variant" "missense_variant")
  for feat in "${FEATURES[@]}"
    do
    echo "${feat}"
    grep "${feat}" $FILE | cut -f8 | cut -d';' -f3 | cut -d'=' -f2 | awk -v pop="$POPULATION" -v feat="${feat}" '{print $1" "pop" "feat}' >> $V_PATH/annotation/features_frequency_distribution_wout1.lr_ann.txt
    done
    cd $V_PATH/annotation/
  done

scp dkleinman@genomics-b.ebd.csic.es:/home/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/annotation/features_frequency_distribution_wout1.lr_ann.txt /Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/features_frequency_distribution/


#Filtered2 with1: for each population (minimum subsample, with1 version) extract allele frequency from all SNPs in each class of interest, and save them in a file:

cd $V_PATH/annotation/
screen -S features_frequency_distribution_filtered2_with1.lr_ann.log
script features_frequency_distribution_filtered2_with1.lr_ann.log

rm $V_PATH/annotation/features_frequency_distribution_filtered2_with1.lr_ann.txt
POPLIST=($(ls -d c_{lp_sm*,lp_do*,ll_ki*,ll_po*,ll_no*}perpop))
for pop in "${POPLIST[@]}"
  do
  echo "${pop}"
  cd $V_PATH/annotation/"${pop}"/
  SPECIES=$(echo "${pop}" | cut -c3-4)
  POPULATION=$(echo "${pop}" | cut -c6-7)
  if [ -e ${pop}_filtered2_minimum_subsample_with1.lr_ann.vcf ]; then
    echo "Minimum "$POPULATION" subsample available"
    FILE=${pop}_filtered2_minimum_subsample_with1.lr_ann.vcf
  elif [ -e ${pop}_filtered2_random_subsample_with1.lr_ann.vcf ]; then
    echo "Random "$POPULATION" subsample available"
    FILE=${pop}_filtered2_random_subsample_with1.lr_ann.vcf
  else
    echo "Original "$POPULATION" available"
    FILE=${pop}_filtered2_with1.lr_ann.vcf
  fi
  declare -a FEATURES=("intergenic" "intron_variant" "synonymous_variant" "missense_variant")
  for feat in "${FEATURES[@]}"
    do
    echo "${feat}"
    grep "${feat}" $FILE | cut -f8 | cut -d';' -f3 | cut -d'=' -f2 | awk -v pop="$POPULATION" -v feat="${feat}" '{print $1" "pop" "feat}' >> $V_PATH/annotation/features_frequency_distribution_filtered2_with1.lr_ann.txt
    done
    cd $V_PATH/annotation/
  done

scp dkleinman@genomics-b.ebd.csic.es:/home/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/annotation/features_frequency_distribution_filtered2_with1.lr_ann.txt /Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/features_frequency_distribution/


#Filtered2 wout1: for each population (minimum subsample, wout1 version) extract allele frequency from all SNPs in each class of interest, and save them in a file:

cd $V_PATH/annotation/
screen -S features_frequency_distribution_filtered2_wout1.lr_ann.log
script features_frequency_distribution_filtered2_wout1.lr_ann.log

rm $V_PATH/annotation/features_frequency_distribution_filtered2_wout1.lr_ann.txt
POPLIST=($(ls -d c_{lp_sm*,lp_do*,ll_ki*,ll_po*,ll_no*}perpop))
for pop in "${POPLIST[@]}"
  do
  echo "${pop}"
  cd $V_PATH/annotation/"${pop}"/
  SPECIES=$(echo "${pop}" | cut -c3-4)
  POPULATION=$(echo "${pop}" | cut -c6-7)
  if [ -e ${pop}_filtered2_minimum_subsample_wout1.lr_ann.vcf ]; then
    echo "Minimum "$POPULATION" subsample available"
    FILE=${pop}_filtered2_minimum_subsample_wout1.lr_ann.vcf
  elif [ -e ${pop}_filtered2_random_subsample_wout1.lr_ann.vcf ]; then
    echo "Random "$POPULATION" subsample available"
    FILE=${pop}_filtered2_random_subsample_wout1.lr_ann.vcf
  else
    echo "Original "$POPULATION" available"
    FILE=${pop}_filtered2_wout1.lr_ann.vcf
  fi
  declare -a FEATURES=("intergenic" "intron_variant" "synonymous_variant" "missense_variant")
  for feat in "${FEATURES[@]}"
    do
    echo "${feat}"
    grep "${feat}" $FILE | cut -f8 | cut -d';' -f3 | cut -d'=' -f2 | awk -v pop="$POPULATION" -v feat="${feat}" '{print $1" "pop" "feat}' >> $V_PATH/annotation/features_frequency_distribution_filtered2_wout1.lr_ann.txt
    done
    cd $V_PATH/annotation/
  done

scp dkleinman@genomics-b.ebd.csic.es:/home/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/annotation/features_frequency_distribution_filtered2_wout1.lr_ann.txt /Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/features_frequency_distribution/

```

##Draw frequency distribution.

```{r Get annotation statistics}

library(readr)
library(dplyr)
library(ggplot2)

#with1:

features_frequency_distribution <- read_delim("/Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/features_frequency_distribution/features_frequency_distribution_with1.lr_ann.txt",col_names=c("AF","pop","feat"),delim=" ")
features_frequency_distribution
features_frequency_distribution$feat <- as.factor(features_frequency_distribution$feat)
features_frequency_distribution$feat = factor(features_frequency_distribution$feat,levels(features_frequency_distribution$feat)[c(1,2,4,3)])
pops <- unique(features_frequency_distribution$pop)
pops
features <- unique(features_frequency_distribution$feat)
features

for (pop in pops) {
  plot_data <- features_frequency_distribution %>% filter(features_frequency_distribution$pop == !!pop) #the two !! allow R to evaluate the text and distinguish looping variables from col_names
  plot_data
  pop_feat_ggplot <- ggplot(data=plot_data, aes(AF)) +
  facet_grid(feat ~ ., scales="free") +
  geom_histogram(aes(AF),binwidth=0.01) +
  ggtitle(paste0("AF distribution for ",pop," with rufus based annotation")) +
  #ylab("density") +
  #xlab("heritability") +
  theme_bw() +
  theme(text=element_text(size=12,face="bold"),
        rect=element_rect(size=1),
        axis.line=element_line(colour="black"),
        axis.title=element_text(size=16),
        #axis.text.x=element_text(angle=45, hjust=1, size=24,colour="black"),
        #axis.text.y=element_text(size=24,colour="black",margin=margin(t=0.5,unit="cm")),
        #axis.title.y=element_text(size=30,margin=margin(r=0.5,unit="cm")),
        panel.background=element_blank(),
        panel.border=element_rect(colour="black"),
        #panel.grid=element_blank(),
        #panel.grid.major=element_line(colour="grey", linetype="dashed", size=0.4),
        plot.margin=unit(c(0.5,1,0.5,0.5),"cm"),
        #plot.title=element_text(size=36, face="bold", margin=margin(b=0.5, unit="cm")),
        legend.background=element_rect(linetype="solid", colour="black", size=.5),
        #legend.justification=c(0,0),
        legend.key=element_rect(colour="white"),
        #legend.key.size=unit(1.3,"cm"),
        legend.position=c(0.92,0.86),
        legend.title=element_blank()
  )
  pop_feat_ggplot
  ggsave(paste0(pop,"_AF_distribution_with1.lr_ann.pdf"), width=30, height=25, units="cm", device="pdf", path="/Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/features_frequency_distribution/lr_ann/with1/")
}

#wout1:

features_frequency_distribution <- read_delim("/Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/features_frequency_distribution/features_frequency_distribution_wout1.lr_ann.txt",col_names=c("AF","pop","feat"),delim=" ")
features_frequency_distribution
features_frequency_distribution$feat <- as.factor(features_frequency_distribution$feat)
features_frequency_distribution$feat = factor(features_frequency_distribution$feat,levels(features_frequency_distribution$feat)[c(1,2,4,3)])
pops <- unique(features_frequency_distribution$pop)
pops
features <- unique(features_frequency_distribution$feat)
features

for (pop in pops) {
  plot_data <- features_frequency_distribution %>% filter(features_frequency_distribution$pop == !!pop) #the two !! allow R to evaluate the text and distinguish looping variables from col_names
  plot_data
  pop_feat_ggplot <- ggplot(data=plot_data, aes(AF)) +
  facet_grid(feat ~ ., scales="free") +
  geom_histogram(aes(AF),binwidth=0.01) +
  ggtitle(paste0("AF distribution for ",pop," with rufus based annotation")) +
  #ylab("density") +
  #xlab("heritability") +
  theme_bw() +
  theme(text=element_text(size=12,face="bold"),
        rect=element_rect(size=1),
        axis.line=element_line(colour="black"),
        axis.title=element_text(size=16),
        #axis.text.x=element_text(angle=45, hjust=1, size=24,colour="black"),
        #axis.text.y=element_text(size=24,colour="black",margin=margin(t=0.5,unit="cm")),
        #axis.title.y=element_text(size=30,margin=margin(r=0.5,unit="cm")),
        panel.background=element_blank(),
        panel.border=element_rect(colour="black"),
        #panel.grid=element_blank(),
        #panel.grid.major=element_line(colour="grey", linetype="dashed", size=0.4),
        plot.margin=unit(c(0.5,1,0.5,0.5),"cm"),
        #plot.title=element_text(size=36, face="bold", margin=margin(b=0.5, unit="cm")),
        legend.background=element_rect(linetype="solid", colour="black", size=.5),
        #legend.justification=c(0,0),
        legend.key=element_rect(colour="white"),
        #legend.key.size=unit(1.3,"cm"),
        legend.position=c(0.92,0.86),
        legend.title=element_blank()
  )
  pop_feat_ggplot
  ggsave(paste0(pop,"_AF_distribution_wout1.lr_ann.pdf"), width=30, height=25, units="cm", device="pdf", path="/Users/Dani/ownCloud/backup/g-w_analysis/genetic_load/features_frequency_distribution/lr_ann/wout1/")
}

```
