---
title: "ucne_database"
author: "Dani"
date: "8 de julio de 2019"
output: html_document
---

#Obtain UCNE variants for every individual:
```{bash}

mkdir -p /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov/annotation/ucne_database
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov/annotation/ucne_database

awk '{printf ("%s\t%s\t%s\t%s\n", $1,$2,$3,$3-$2)}' /home/datos_usuarios/dkleinman/snpEff/data/LYPA23C.UCNE.bed > ucne_coordinates.bed


CALLING=(c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov)
VAR=(varssubs) #varssubs #variants #substitutions
TYPE=(SNP) #write down SNP or INDEL
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database
screen -S "${CALLING}-${VAR}-${TYPE}"
CALLING=$(echo ${STY#*.} | cut -d'-' -f1)
VAR=$(echo ${STY#*.} | cut -d'-' -f2)
TYPE=$(echo ${STY#*.} | cut -d'-' -f3)
script "${CALLING}_ucne_database_${VAR}_${TYPE}.lr_ann.log"
CALLING=$(echo ${STY#*.} | cut -d'-' -f1)
VAR=$(echo ${STY#*.} | cut -d'-' -f2)
TYPE=$(echo ${STY#*.} | cut -d'-' -f3)

S_PATH=/opt/snpEff #software path
C_PATH=/home/dkleinman/datos/snpEff #config file path
O_PATH=/home/dkleinman/datos/snpEff #output path
I_PATH=/home/GRUPOS/grupolince/immunocapture/prueba_highdiv #immunocapture path
V_PATH=/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs #VCFs path
G_PATH=/GRUPOS/grupolince/lynx_genomes_5x/gVCFs #gVCFs path
B_PATH=/home/GRUPOS/grupolince/lynx_genomes_5x/BAM_files_final #BAM files path
REF=/home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa #path to reference genome
GATK=/opt/GATK-3.7/GenomeAnalysisTK.jar #GATK software path
BCF=/opt/bcftools-1.6/bcftools #BCFtools software path

cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov/annotation/
INDLIST=($(ls `find . -name *"_individual_"${VAR}"_"${TYPE}".lr_ann.vcf" ! -path '*testing_variant_numbers*' -print`))
for i in "${INDLIST[@]}"
  do
  echo "${i}"
  ind=$(echo "${i}" | awk -F'[/]' '{print $3}' | cut -c1-12)
  echo "${ind}"
  SPECIES=$(echo "${ind}" | cut -c3-4)
  POPULATION=$(echo "${ind}" | cut -c6-7)
  DATASET=$(if [ $ind = "c_lp_sm_0221" ]; then echo "REF"; elif [ $ind = "c_ll_ki_0090" ]; then echo "MG"; elif [ $ind = "h_ll_pv_0223" ]; then echo "LD"; elif grep -Fxq $ind /GRUPOS/grupolince/lynx_genomes_5x/BAM_files_final/c_lp_5x_samples || [ $SPECIES = "ll" ]; then echo "5x"; else echo "GP"; fi)
  SAMPLE=$(echo "${ind}" | cut -c9-12)
  grep 'UCNE' ${i} | cut -f1,2 | awk -v ind=$ind -v population=$POPULATION -v dataset=$DATASET '{printf ("%s\t%s\t%s\t%s\t%s\t%s\n", $1, $2-1, $2, population, dataset, ind)}' > ./ucne_database/ucne_variants_${ind}.bed
  done

```

#Analyse density and distribution of variants:
##Obtain density and distribution of variants
```{bash}

#Obtain variant density per UCNE region:
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov/annotation/ucne_database

screen -S ucne_coordinates_complete_info
FILES=($(ls ucne_variants*.bed))
for f in "${FILES[@]}"
  do
  #echo "${f}"
  POPULATION=$(cut -f 4 "${f}" | head -n1)
  DATASET=$(cut -f 5 "${f}" | head -n1)
  IND=$(cut -f 6 "${f}" | head -n1)
  echo $IND
  echo -e "scaffold\tposition_start\tposition_end\tlength\tvariant_N\tvariant_density\tpopulation\tdataset\tindividual" > ${f/ucne_variants/ucne_coordinates_complete_info}
  while read -r entry; do
    echo "$entry" > row.bed
    bedtools intersect -a row.bed -b "${f}" > temp.bed
    VARIANT_N=$(wc -l < temp.bed)
    SITES_N=$(echo "$entry" | cut -f 4)
    DENSITY=$(echo "scale=3; $VARIANT_N/$SITES_N" | bc)
    echo -e "$entry\t$VARIANT_N\t$DENSITY\t$POPULATION\t$DATASET\t$IND" >> ${f/ucne_variants/ucne_coordinates_complete_info}
    done < ucne_coordinates.bed
  done

#Obtain variants distribution within the UCNE regions:
screen -S ucne_variants_distribution_info
FILES=($(ls ucne_variants_c*.bed))
for f in "${FILES[@]}"
  do
  echo "${f}"
  POPULATION=$(cut -f 4 "${f}" | head -n1)
  DATASET=$(cut -f 5 "${f}" | head -n1)
  IND=$(cut -f 6 "${f}" | head -n1)
  echo $IND
  echo -e "scaffold\tposition_start\tposition_end\tpopulation\tdataset\tindividual\tregion_start\tregion_end\tstart_distance_prop" > ${f/ucne_variants/ucne_variants_distribution_info}
  while read -r entry; do
    echo "$entry" | cut -f1,2,3 > row.bed
    bedtools intersect -wa -wb -a row.bed -b ucne_coordinates.bed > temp.bed
    VARIANT_POS=$(cut -f 3 temp.bed)
    START_POS=$(cut -f 5 temp.bed)
    END_POS=$(cut -f 6 temp.bed)
    START_DISTANCE=$((VARIANT_POS-START_POS))
    REGION_LENGTH=$(cut -f 7 temp.bed)
    PROP_DISTANCE=$(echo "scale=3; $START_DISTANCE/$REGION_LENGTH" | bc) 
    echo -e "$entry\t$START_POS\t$END_POS\t$PROP_DISTANCE" >> ${f/ucne_variants/ucne_variants_distribution_info}
    done < ${f}
  done

rm ucne_variants_distribution_info_allsamples.bed
FILES=($(ls ucne_variants_distribution_info_c*.bed))
for f in "${FILES[@]}"
  do
  echo "${f}"
  tail -n+2 "${f}" | cut -f6,9 >> ucne_variants_distribution_info_allsamples.bed
  done

#From outside the server:
scp dkleinman@genomics-b.ebd.csic.es:/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov/annotation/ucne_database/ucne_variants_distribution_info_allsamples.bed /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db

```

##Plot distribution of variants:
```{r}
library(readr)
library(dplyr)
library(ggplot2)
library(tidyr)


ucne_variants_distribution <- read_tsv("/Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/ucne_variants_distribution_info_allsamples.bed",col_names=c("sample","start_distance_prop")) 

!!!GROUP VARIANTS IN TEN GROUPS (DECATILES) AND PLOT COUNTS

for (s in unique(ucne_variants_distribution$sample)) {
  ucne_variants_distribution_sample <- arrange(filter(ucne_variants_distribution,ucne_variants_distribution$sample==s),start_distance_prop) %>% group_by(start_distance_prop) %>% tally() %>% mutate(n_cum=cumsum(n), avg=start_distance_prop*n)
  average_start_distance_prop <- mean(ucne_variants_distribution_sample$avg)
  total_n_cum <- tail(ucne_variants_distribution_sample,1)$n_cum
  ucne_variants_distribution_sample_top <- filter(ucne_variants_distribution_sample,start_distance_prop>=0.8)
  top_proportion <- 1-sum(ucne_variants_distribution_sample_top$n)/total_n_cum
  ucne_variants_distribution_sample_bottom <- filter(ucne_variants_distribution_sample,start_distance_prop<=0.2)
  bottom_proportion <- sum(ucne_variants_distribution_sample_bottom$n)/total_n_cum
  ucne_variants_distribution_sample_plot <- ggplot(data=ucne_variants_distribution_sample,aes(x=start_distance_prop,y=n_cum*100/total_n_cum)) +
    geom_line() +
    geom_vline(xintercept=average_start_distance_prop,colour="red") +
    geom_vline(xintercept=top_proportion,colour="blue") +
    geom_vline(xintercept=bottom_proportion,colour="green") +
    ggtitle(s) +
    xlab("distance from region start (proportion)") +
    ylab("cumulative variants (proportion)")
  ucne_variants_distribution_sample_plot
  ggsave(paste0("ucne_variants_distribution_",s,".pdf"), width=15, height=10, units="cm", device="pdf", path="/Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db")
}

```

#Analyse conservation status (GERP).
```{bash}

cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov/annotation/ucne_database/test
#Split the UCNE coordinates across chromosomes, and then retrieve the GERP scores for each chromosome (otherwise there's a limit to the number of regions allowed) from here: https://genome.ucsc.edu/cgi-bin/hgTables. Don't forget to manually change the name of each output file.
#Detailed explanation: http://mendel.stanford.edu/SidowLab/downloads/gerp/Readme.txt.
CHR=$(cut -f1 /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/UCNE_beds/hg19_UCNE_coord.bed | uniq)
for chr in ${CHR[@]}
  do
  echo ${chr}
  awk -v chr=$chr '{if ($1 == chr) printf ("%s\t%s\t%s\t%s_%s\n", $1, $2-1, $3, $4, $5)}' /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/UCNE_beds/hg19_UCNE_coord.bed > /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/UCNE_beds/hg19_UCNE_coord_${chr}.bed
  done

#Once all .gerp files have been downloaded and placed in the proper folder, convert them to .bed format.
CHR=$(cut -f1 /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/UCNE_beds/hg19_UCNE_coord.bed | uniq)
for chr in ${CHR[@]}
  do
  echo ${chr}
  grep -vE '#|variableStep|track' /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/UCNE_beds/hg19_GERP_coord_${chr}.gerp | awk -v chr=$chr '{printf ("%s\t%s\t%s\t%s\n", chr, $1-1, $1, $2)}' > /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/UCNE_beds/hg19_GERP_coord_${chr}.bed
  done


#In the server (to use bedtools):
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov/annotation/ucne_database/test

#Intersect human UCNE and GERP information:
bedtools intersect -wa -wb -a hg19_GERP_coord_${chr}.bed -b hg19_UCNE_coord_${chr}.bed | awk '{printf ("%s\t%s\t%s\t%s\t%s\n", $1, $2, $3, $4, $8)}' > hg19_GERP_coord_${chr}_complete.bed



Run LiftOver:
/Applications/LiftOver/liftOver -minMatch=0.1 /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/UCNE_beds/hg19_GERP_coord_chr1_complete.bed /Applications/LiftOver/hg19ToFelCat5.over.chain.gz /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/UCNE_beds/cat_GERP_coord_chr1_complete.bed /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/UCNE_beds/cat_GERP_coord_chr1_unlifted.bed



Run LiftOver:
head -n 100 /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/UCNE_beds/hg19_GERP_coord_chr1.bed > /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/UCNE_beds/kaka.bed

/Applications/LiftOver/liftOver -minMatch=0.1 /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/UCNE_beds/kaka.bed /Applications/LiftOver/hg19ToFelCat5.over.chain.gz /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/UCNE_beds/kaka_out.bed /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/UCNE_beds/kaka_unlifted.bed



```

#Obsolete (I thought I could join cat and human coordinates based on the UCNE name, but I don't know the nucleotide correspondence so GERP values won't make sense).
```{bash}

#Get file with cat coordinates, and then split the regions to the nucleotide level:
awk '{printf ("%s\t%s\t%s\t%s_%s\n", $1, $2, $3, $4, $5)}' /home/GRUPOS/grupolince/ultra_conserved_regions/cat_conversion_UCNE_coord_from_hg19_sorted.bed > cat_conversion_UCNE_coord_from_hg19_sorted.bed

screen -S cat_conversion_UCNE_coord_from_hg19_sorted_detailed.log

rm cat_conversion_UCNE_coord_from_hg19_sorted_detailed.bed
touch cat_conversion_UCNE_coord_from_hg19_sorted_detailed.bed
FILE=cat_conversion_UCNE_coord_from_hg19_sorted.bed
COUNTER=0
TOTAL=$(wc -l < $FILE)
while read -r chr start end info
  do
  if [ $(( $COUNTER % 10 )) == 0 ]
    then
    echo "processed $COUNTER regions out of $TOTAL"
  fi
  while [ $start -lt $end ]
    do
    stop=$((start+1))
    echo -e "$chr\t$start\t$stop\t$info" >> ${FILE/.bed/_detailed.bed}
    ((start++))
    done
  ((COUNTER++))
  done < $FILE



#Join cat coordinates with human UCNE and GERP information:
join -1 4 -2 5 <(sort -k4 test.bed) <(sort -k5 hg19_GERP_coord_${chr}_complete.bed) | awk '{printf ("%s\t%s\t%s\t%s\t%s\n", $2, $3, $4, $1, $8)}' | bedtools sort > cat_GERP_coord_${chr}_complete.bed

```

#Obtain GERP scores via human-lynx BLAST alignments.
##Make local BLAST database for human GRCH37:
```{bash}

#I need to retrieve the coordinate equivalence between human GRCH37/hg19 (where GERP scores are defined) and lynx. I wasn't able to find the GRCH37/hg19 database in the ncbi web, but I found a link with all GRCH37/hg19 fastas and a guide on how to build my own GRCH37/hg19 database from those fastas. This is the link with the GRCH37/hg19 fastas: http://hgdownload.soe.ucsc.edu/goldenPath/hg19/bigZips/chromFa.tar.gz. This is the link with the explanation: https://www.biostars.org/p/233113/

#I copied all files in chromFa.tar.gz (after uncompressing) to the following genomics folder:
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov/annotation/ucne_database/gerp_analysis/GRCH37_blast_database

#Then I placed them all in a single file:
cat chr* > GRCH37.fa

#Then I built the BLAST database:
/GRUPOS/grupolince/ncbi-blast-2.6.0+/bin/makeblastdb -in GRCH37.fa -parse_seqids -title "GRCH37" -dbtype nucl

```

##Blast lynx UCNE regions against human GRCH37:
```{bash}

CALLING=(c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov) #write down name of the calling
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis

#First, obtain the multifasta for the UCNE region:
bedtools getfasta -fi /GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa -bed /home/datos_usuarios/dkleinman/snpEff/data/LYPA23C.UCNE.bed -fo ${CALLING}.UCNE.fa

#Then, use BLAST to obtain the alignments against human GRCH37 in two useful formats: tabular (format 6) with basic information, and xml (format 5), which is necessary to then obtain gap information.
/GRUPOS/grupolince/ncbi-blast-2.6.0+/bin/blastn -db ./GRCH37_blast_database/GRCH37.fa -query ${CALLING}.UCNE.fa -out ${CALLING}.UCNE.blast.txt -outfmt "6 qseqid sseqid pident length mismatch gapopen qstart qend sstrand sstart send evalue bitscore"

/GRUPOS/grupolince/ncbi-blast-2.6.0+/bin/blastn -db ./GRCH37_blast_database/GRCH37.fa -query ${CALLING}.UCNE.fa -out ${CALLING}.UCNE.blast.xml -outfmt 5

#Remove suboptimal alignments:
sort -u -k1,1 ${CALLING}.UCNE.blast.txt > ${CALLING}.UCNE.blast_uniq.txt
mv ${CALLING}.UCNE.blast_uniq.txt ${CALLING}.UCNE.blast.txt

```

##Obtain gap coordinates using BlastNToSnp:
###Install BlastNToSnp:
```{bash}

#Gaps break the 1:1 equivalence of coordinates in many alignments, so a workaround is needed. BlastNToSnp (http://lindenb.github.io/jvarkit/BlastNToSnp.html) takes the xml output of blast and retrieves information on mismatches and gaps.

#I installed the programme in my local environment:
cd /Applications/

git clone "https://github.com/lindenb/jvarkit.git"
cd jvarkit
./gradlew blastn2snp

```

###Run BlastNToSnp:
```{bash}

#First, I copy the BLAST xml output to the local folder:
CALLING=(c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov) #write down name of the calling
mkdir -p /Applications/jvarkit/$CALLING
cd /Applications/jvarkit/$CALLING

scp dkleinman@genomics-b.ebd.csic.es:/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis/${CALLING}.UCNE.blast.xml /Applications/jvarkit/$CALLING

#Then I run the programme:
java -jar ./../dist/blastn2snp.jar -n -1 ${CALLING}.UCNE.blast.xml > ${CALLING}.UCNE.blast.gaps

#Then I remove data from suboptimal alignments and columns 8 & 9 (which contain empty data):
head -n1 ${CALLING}.UCNE.blast.gaps | cut -f-7,10- > ${CALLING}.UCNE.blast_uniq.gaps
awk -F"\t" '($3 == "1") && ($4 == "1") {print $0}' ${CALLING}.UCNE.blast.gaps | cut -f-7,10- >> ${CALLING}.UCNE.blast_uniq.gaps

#Then I remove data relative to mismatches, leaving only the gap information:
head -n1 ${CALLING}.UCNE.blast_uniq.gaps > ${CALLING}.UCNE.blast_uniq_filtered.gaps
awk -F"\t" '$9~/-/ || $10~/-/' ${CALLING}.UCNE.blast_uniq.gaps >> ${CALLING}.UCNE.blast_uniq_filtered.gaps

mv ${CALLING}.UCNE.blast_uniq_filtered.gaps ${CALLING}.UCNE.blast.gaps
rm ${CALLING}.UCNE.blast_uniq.gaps

#And I move the file back to the server:
scp /Applications/jvarkit/$CALLING/${CALLING}.UCNE.blast.gaps dkleinman@genomics-b.ebd.csic.es:/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis/

```

##Generate bed with human coordinates and the exact lynx equivalence:
```{bash}

CALLING=(c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov)
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis


rm GRCH37.$CALLING.UCNE.equivalence.bed
FILE=$(echo $CALLING.UCNE.blast.txt)
while IFS=$'\t' read -r qseqid sseqid pident length mismatch gapopen qstart qend sstrand sstart send evalue bitscore
  do
  echo $qseqid "qseqid"
  lp23scaffold=$(echo $qseqid | cut -d':' -f1)
  echo $lp23scaffold "lp23scaffold"
  lp23start=$(echo ${qseqid#*:} | cut -d'-' -f1)
  echo $lp23start "lp23start"
  alignstart=$((lp23start+qstart))
  echo $alignstart "alignstart"
  #lp23end=$(echo ${qseqid#*:} | cut -d'-' -f2)
  alignend=$((lp23start+qend))
  echo $alignend "alignend"
  if [ $gapopen == 0 ] && [ $sstrand == "plus" ]
    then
    echo -e "$sseqid\t$((sstart-1))\t$send\t$lp23scaffold:$((alignstart-1))-$alignend\t$qseqid" >> GRCH37.$CALLING.UCNE.equivalence.bed
    #Minus 1 to convert from 1-based to 0-based
  elif [ $gapopen == 0 ] && [ $sstrand == "minus" ]
    then
    echo -e "$sseqid\t$((send-1))\t$sstart\t$lp23scaffold:$alignend-$((alignstart-1))\t$qseqid" >> GRCH37.$CALLING.UCNE.equivalence.bed
    #Minus 1 to convert from 1-based to 0-based
  elif [ $gapopen -ge 1 ] && [ $sstrand == "plus" ]
    then
    grep $qseqid ${FILE/blast.txt/blast.gaps} > working.grep.borrar
    row_counter=0
    nrow=$(wc -l < working.grep.borrar)
    while IFS=$'\t' read -r query hit hitindex hspindex querypos hitpos strand alignlength hitvar queryvar midvar
      do
      ((row_counter++))
      if [ $row_counter == 1 ] #Before the first gap, define region start as the alignment start
        then
        hitstart=$sstart
        echo $hitstart "hitstart"
        querystart=$alignstart
        echo $querystart "querystart"
      else #Before other gaps, define region start as the position after the previous gap
        hitstart=$((hitend+querygap+1))
        querystart=$((queryend+hitgap+1))
      fi #Define region end as the position before the current gap
      hitgap=$(echo $hitvar | tr -cd '-' | wc -c)
      echo $hitvar "hitvar"
      echo $hitgap "hitgap"
      querygap=$(echo $queryvar | tr -cd '-' | wc -c)
      echo $queryvar "queryvar"
      echo $querygap "querygap"
      hitend=$((hitpos-1))
      echo $hitend "hitend"
      queryend=$((lp23start+querypos-1))
      echo $queryend "queryend"
      echo -e "$sseqid\t$((hitstart-1))\t$hitend\t$lp23scaffold:$((querystart-1))-$queryend\t$qseqid" >> GRCH37.$CALLING.UCNE.equivalence.bed
      if [ $row_counter == $nrow ] #After the last gap, define region end as the alignment end
        then
        lasthitstart=$((hitend+querygap+1))
        echo $lasthitstart "lasthitstart"
        lastquerystart=$((queryend+hitgap+1))
        echo $lastquerystart "lastquerystart"
        lasthitend=$send
        echo $lasthitend "lasthitend"
        lastqueryend=$alignend
        echo $lastqueryend "lastqueryend"
        echo -e "$sseqid\t$((lasthitstart-1))\t$lasthitend\t$lp23scaffold:$((lastquerystart-1))-$lastqueryend\t$qseqid" >> GRCH37.$CALLING.UCNE.equivalence.bed
      fi
      done < working.grep.borrar
  elif [ $gapopen -ge 1 ] && [ $sstrand == "minus" ]
    then
    grep $qseqid ${FILE/blast.txt/blast.gaps} > working.grep.borrar
    row_counter=0
    nrow=$(wc -l < working.grep.borrar)
    while IFS=$'\t' read -r query hit hitindex hspindex querypos hitpos strand alignlength hitvar queryvar midvar
      do
      ((row_counter++))
      if [ $row_counter == 1 ] #Before the first gap, define region start as the alignment start
        then
        hitstart=$sstart
        echo $hitstart "hitstart"
        querystart=$alignstart
        echo $querystart "querystart"
      else #Before other gaps, define region start as the position after the previous gap
        hitstart=$((hitend-querygap-1))
        querystart=$((queryend+hitgap+1))
      fi #Define region end as the position before the current gap
      hitgap=$(echo $hitvar | tr -cd '-' | wc -c)
      echo $hitvar "hitvar"
      echo $hitgap "hitgap"
      querygap=$(echo $queryvar | tr -cd '-' | wc -c)
      echo $queryvar "queryvar"
      echo $querygap "querygap"
      hitend=$((hitpos+1))
      echo $hitend "hitend"
      queryend=$((lp23start+querypos-1))
      echo $queryend "queryend"
      echo -e "$sseqid\t$((hitend-1))\t$hitstart\t$lp23scaffold:$queryend-$((querystart-1))\t$qseqid" >> GRCH37.$CALLING.UCNE.equivalence.bed
      if [ $row_counter == $nrow ] #After the last gap, define region end as the alignment end
        then
        lasthitstart=$((hitend-querygap-1))
        echo $lasthitstart "lasthitstart"
        lastquerystart=$((queryend+hitgap+1))
        echo $lastquerystart "lastquerystart"
        lasthitend=$send
        echo $lasthitend "lasthitend"
        lastqueryend=$alignend
        echo $lastqueryend "lastqueryend"
        echo -e "$sseqid\t$((lasthitend-1))\t$lasthitstart\t$lp23scaffold:$lastqueryend-$((lastquerystart-1))\t$qseqid" >> GRCH37.$CALLING.UCNE.equivalence.bed
      fi
      done < working.grep.borrar
  fi
  done < $FILE
rm working.grep.borrar

#Now remove the useless rows that were generated when deletions were consecutive, and sort the bed:
awk -F"\t|:|-" '($2 != $3) || ($5 != $6) {print $0}' GRCH37.$CALLING.UCNE.equivalence.bed | sort -k1,1 -k2,2n -k3,3n > GRCH37.$CALLING.UCNE.equivalence_sorted_uniq.bed
mv GRCH37.$CALLING.UCNE.equivalence_sorted_uniq.bed GRCH37.$CALLING.UCNE.equivalence.bed

wc -l < GRCH37.$CALLING.UCNE.equivalence.bed #5588

#Sanity check: count the length of each human segment and its lynx equivalent, then for each region subtract both numbers, then count the number of regions where the subtracted number is higher than 0. If everything's ok, the following code should output 0. 
awk -F"\t|:|-" '{printf("%f\t%f\n",$3-$2,sqrt(($6-$5)^2))}' GRCH37.$CALLING.UCNE.equivalence.bed | awk -F"\t" '{printf("%f\t%f\t%f\n",$1,$2,$2-$1)}' | awk -F"\t" '($3 > 0) {print $0}' | wc -l #0 (it seems like everything's ok)

#Since the UCSC browser that we'll be using next to retrieve the GERP scores has a limit of 1000 regions per query, we need to break the GRCH37.$CALLING.UCNE.equivalence.bed file in at least 6 files.
TOTAL_ROWS=$(wc -l < GRCH37.$CALLING.UCNE.equivalence.bed)
UCSC_LIMIT=1000
FILES_REQUIRED=$(echo $(((TOTAL_ROWS+UCSC_LIMIT-1)/UCSC_LIMIT))) #TOTAL_ROWS+UCSC_LIMIT-1 is a trick to round the division up to the next integer
ROWS_PER_FILE=$(echo $(((TOTAL_ROWS+FILES_REQUIRED-1)/FILES_REQUIRED)))

START=1
#echo $START
END=$ROWS_PER_FILE
#echo $END
for part in $(seq ${FILES_REQUIRED[@]})
  do
  #echo ${part}
  sed -n $START','$END'p' GRCH37.$CALLING.UCNE.equivalence.bed | awk -F"\t" '{printf("%s\t%s\t%s\t%s\n",$1,$2,$3,$4)}' > GRCH37.$CALLING.UCNE.equivalence_part_${part}.bed
  START=$((END+1))
  #echo $START
  END=$((START+ROWS_PER_FILE-1))
  #echo $END
  done

```

##Retrieve GERP scores from human coordinates:
```{bash}

#From outside the server, download all bed files to the local folder:
CALLING=(c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov)
scp dkleinman@genomics-b.ebd.csic.es:/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis/GRCH37.$CALLING.UCNE.equivalence_part*.bed /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/GERP_analysis

#Then go to the website: https://genome.ucsc.edu/cgi-bin/hgTables, set genome as human, assembly as GRCh37/hg19 from Feb. 2009, group as comparative genomics, track as GERP, region as defined region and submit one of the equivalence_part_${part}.bed file generated in the previous section. Write down the respective name of the output in the blank box as equivalence_part_${part}.gerp, click 'output' and then in the next window click 'get custom track in file' to start the download. Repeat the process for the rest of the parts, and move all downloaded .gerp files to /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/GERP_analysis

#Then upload all bed files to the server:
CALLING=(c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov)
scp /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/GERP_analysis/GRCH37.$CALLING.UCNE.equivalence_part*.gerp dkleinman@genomics-b.ebd.csic.es:/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis/ 

```

##Convert GERP scores back to bed format:
```{bash}

#Once all .gerp files have been uploaded, convert them to .bed format.
CALLING=(c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov)
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis/temporary_folder

rm ./../GRCH37.$CALLING.UCNE.equivalence_part_*.gerp.bed
GERP_FILES=$(ls ./../GRCH37.$CALLING.UCNE.equivalence_part_*.gerp | wc -l)
for part in $(seq ${GERP_FILES[@]})
  do
  echo "breaking down part" $part
  grep -vE '#|track' ./../GRCH37.$CALLING.UCNE.equivalence_part_${part}.gerp | awk -v partname=UCNE.equivalence_part_${part} '/variableStep/{filename=partname"."NR".txt"}; {print >filename}'
  PART_FILES=$(ls UCNE.equivalence_part_${part}.*.txt)
  echo "generating bed file of part" $part
  for file in ${PART_FILES[@]}
    do
    CHR=$(head -n1 $file | awk -F" |=" '{printf("%s\n",$3)}')
    tail -n+2 $file | awk -v chr=$CHR '{printf("%s\t%s\t%s\t%s\n",chr,$1-1,$1,$2)}' >> ./../GRCH37.$CALLING.UCNE.equivalence_part_${part}.gerp.bed
    done
  bedtools sort -i ./../GRCH37.$CALLING.UCNE.equivalence_part_${part}.gerp.bed > ./../GRCH37.$CALLING.UCNE.equivalence_part_${part}_sorted.gerp.bed
  mv ./../GRCH37.$CALLING.UCNE.equivalence_part_${part}_sorted.gerp.bed ./../GRCH37.$CALLING.UCNE.equivalence.gerp.bed
  done

cat ./../GRCH37.$CALLING.UCNE.equivalence_part_*.gerp.bed > ./../GRCH37.$CALLING.UCNE.equivalence.gerp.bed

#Calculate average GERP score in our dataset:
awk '{total += $4; count++} END {print total/count}' ./../GRCH37.$CALLING.UCNE.equivalence.gerp.bed #5.11467 is a very high score, implying that our UCNE regions are indeed highly conserved, and thus well annotated.


#Perform sanity checks:
#1:
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis/temporary_folder
ls UCNE.equivalence_part_*.txt | wc -l #5587, even though it should be 5588

#2:
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis/temporary_folder
GERP_FILES=$(ls ./../GRCH37.$CALLING.UCNE.equivalence_part_*.gerp | wc -l)
for part in $(seq ${GERP_FILES[@]})
  do
  PART_FILES_N=$(ls UCNE.equivalence_part_${part}.*.txt | wc -l)
  echo "part" $part "has" $PART_FILES_N "files"
  done #They should all have 932, except for the last one, that should have 928. The third one has 931.

#3:
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis/
GERP_FILES=$(ls GRCH37.$CALLING.UCNE.equivalence_part_*.gerp | wc -l)
for part in $(seq ${GERP_FILES[@]})
  do
  BED_REGIONS_LENGTH=$(awk -F"\t" '{printf("%s\t%s\t%s\n",$2,$3,$3-$2)}' GRCH37.$CALLING.UCNE.equivalence_part_${part}.bed | cut -f3 | paste -sd+ | bc)
  GERP_POSITIONS_N=$(wc -l < GRCH37.$CALLING.UCNE.equivalence_part_${part}.gerp.bed)
  echo $BED_REGIONS_LENGTH "should be equal to" $GERP_POSITIONS_N
  done #Again, the third part has a region whose GERP scores weren't successfully retrieved.

#4:
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis/temporary_folder
rm ./../GRCH37.$CALLING.UCNE.equivalence_part_3.test.bed
PART_FILES=$(ls UCNE.equivalence_part_3.*.txt)
for file in ${PART_FILES[@]}
  do
  CHR=$(head -n1 $file | awk -F" |=" '{printf("%s\n",$3)}')
  START=$(head -n2 $file | tail -n1 | cut -f1)
  END=$(tail -n1 $file | cut -f1)
  echo -e "$CHR\t$((START-1))\t$END" >> ./../GRCH37.$CALLING.UCNE.equivalence_part_3.test.bed
  done
bedtools sort -i ./../GRCH37.$CALLING.UCNE.equivalence_part_3.test.bed | cut -f1,2,3 > ./../GRCH37.$CALLING.UCNE.equivalence_part_3_sorted.test.bed
mv ./../GRCH37.$CALLING.UCNE.equivalence_part_3_sorted.test.bed ./../GRCH37.$CALLING.UCNE.equivalence_part_3.test.bed
cd ./../
cut -f1,2,3 GRCH37.$CALLING.UCNE.equivalence_part_3.bed > test.bed
diff GRCH37.c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.equivalence_part_3.test.bed test.bed #chr1_gl000191_random	47727	48104
#So the problematic row was one region that mapped to an undefined region of GRCH37, for which GERP scores were probably not defined. It's safe to discard it.
rm *test.bed

rm -r temporary_folder

```

##Convert human coordinates with GERP scores to lynx coordinates:
```{bash}

#First, remove the problematic rows from the general equivalence bed:
CALLING=(c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov)
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis/
grep -v 'random' GRCH37.$CALLING.UCNE.equivalence.bed | awk -F"\t|:|-" '{printf("%s\t%s\t%s\t%s\t%s\t%s\t%s:%s-%s\n",$1,$2,$3,$4,$5,$6,$7,$8,$9)}' > GRCH37.$CALLING.UCNE.equivalence.filtered.bed
wc -l < GRCH37.$CALLING.UCNE.equivalence.filtered.bed #5587, as expected after the removal of one row

#Then split both the human regions and the lynx regions to the nucleotide level:
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis/
screen -S "${CALLING}-UCNE-detailed"
CALLING=$(echo ${STY#*.} | cut -d'-' -f1)
script "${CALLING}.UCNE.equivalence.detailed.log"
CALLING=$(echo ${STY#*.} | cut -d'-' -f1)

FILE=GRCH37.$CALLING.UCNE.equivalence.filtered.bed
rm ${FILE/.filtered.bed/.detailed.bed}
touch ${FILE/.filtered.bed/.detailed.bed}
COUNTER=0
TOTAL=$(wc -l < $FILE)
while read -r human_chr human_start human_end lynx_chr lynx_start lynx_end info
  do
  if [ $(( $COUNTER % 100 )) == 0 ]
    then
    echo "processed $COUNTER regions out of $TOTAL"
  fi
  while [ $human_start -lt $human_end ]
    do
    human_stop=$((human_start+1))
    if [ $lynx_start -lt $lynx_end ]
      then
      lynx_frame=1
      lynx_stop=$((lynx_start+lynx_frame))
      echo -e "$human_chr\t$human_start\t$human_stop\t$lynx_chr\t$lynx_start\t$lynx_stop\t$info" >> ${FILE/.filtered.bed/.detailed.bed}
    elif [ $lynx_start -gt $lynx_end ]
      then
      lynx_frame=-1
      lynx_stop=$((lynx_start+lynx_frame))
      echo -e "$human_chr\t$human_start\t$human_stop\t$lynx_chr\t$lynx_stop\t$lynx_start\t$info" >> ${FILE/.filtered.bed/.detailed.bed}
    fi
    ((human_start++))
    lynx_start=$((lynx_start+lynx_frame))
    done
  ((COUNTER++))
  done < $FILE

#Finally, paste together the just created human-lynx equivalence bed file with regions defined base by base, and the base by base bed file with the GERP scores.
paste GRCH37.$CALLING.UCNE.equivalence.detailed.bed GRCH37.$CALLING.UCNE.equivalence.gerp.bed > GRCH37.$CALLING.UCNE.equivalence.detailed.gerp.bed

#Also get a version with just the lynx coordinates and the GERP scores:
cut -f4-6,11 GRCH37.$CALLING.UCNE.equivalence.detailed.gerp.bed | bedtools sort > $CALLING.UCNE.gerp.bed

#Sanity checks:
#1: check whether the use of paste was safe (i.e. if human coordinates for any given row were the same in both files):
wc -l < GRCH37.$CALLING.UCNE.equivalence.detailed.gerp.bed #1282672
awk -F"\t" '($2 == $9) && ($3 == $10) {print $0}' GRCH37.$CALLING.UCNE.equivalence.detailed.gerp.bed | wc -l #1282672, same number, which means all rows have the correct human start and end positions, and thus the paste command was safe.

#2: check whether any of the positions that we deleted from the human coordinates (because they were missing from lynx) appears in the final equivalence .bed file:
join -1 1 -2 1 -t $'\t' <(sort c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.blast.txt) <(sort c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.blast.gaps) | awk -F"\t" '($22 == "-") {printf ("%s\t%s\t%s\n", $2, $18-1, $18)}' > GRCH37.UCNE.human_deleted_gaps.bed
bedtools intersect -a GRCH37.UCNE.gaps.bed -b GRCH37.c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.equivalence.detailed.gerp.bed | wc -l #This should output 0 (we're intersecting the lynx deletions, i.e. the positions that we had to delete from the human genome, with the final coordinates-equivalence file, human coordinates version). It does, so it's fine!


#3: check whether any of the positions that we deleted from the lynx coordinates (because they were missing from human) appears in the final equivalence .bed file. This involves multiple steps:
#A: retrieve regions (whole) where we had to delete positions:
cut -f5 GRCH37.c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.equivalence.bed | uniq -d | awk -F"\t|:|-" '{printf ("%s\t%s\t%s\n", $1, $2, $3)}' | bedtools sort > c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.scaffold_gaps_whole.bed

#B: retrieve regions (deletions already excluded) where we had to delete positions:
join -1 1 -2 5 -t $'\t' <(cut -f5 GRCH37.c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.equivalence.bed | uniq -d | sort) <(sort -k5,5 GRCH37.c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.equivalence.bed) | awk -F"\t|:|-" '{if ($9 >= $8) {printf ("%s\t%s\t%s\n", $7, $8, $9)} else {printf ("%s\t%s\t%s\n", $7, $9, $8)}}' | bedtools sort > c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.scaffold_gaps_split.bed

#C: subtract the second file from the first in order to retrieve coordinates from the deleted positions:
bedtools subtract -a c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.scaffold_gaps_whole.bed -b c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.scaffold_gaps_split.bed > c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.gaps.bed

#D: intersect the previous file with the final coordinates-equivalence file (lynx coordinates version):
bedtools intersect -a c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.gaps.bed -b c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.gerp.bed | wc -l #This outputs 0 as it should! Everything seems to be working fine!!

```

##Obtain version for the derived positions only (both segregating and fixed):
```{bash}

#First, subset the Iberian lynx coordinates file with GERP scores to keep only derived positions (i.e. those that appear in the VCF, whether segregating or fixed)
CALLING=(c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov)
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation
grep 'UCNE' ${CALLING}_polarized_filteredall_varssubs_SNP.lr_ann.vcf | cut -f1,2 | awk '{printf ("%s\t%s\t%s\n", $1, $2-1, $2)}' > ucne_database/gerp_analysis/$CALLING.UCNE.derived.bed
cd ucne_database/gerp_analysis/
bedtools intersect -a $CALLING.UCNE.gerp.bed -b $CALLING.UCNE.derived.bed > $CALLING.UCNE.derived.gerp.bed

#Calculate average GERP score for derived positions:
awk '{total += $4; count++} END {print total/count}' $CALLING.UCNE.derived.gerp.bed #3.92908, quite lower than the all-sites one.

#Next, split the derived positions .bed file into several GERP categories.
awk -F"\t|:|-" '($4 <= 2) {print $0}' $CALLING.UCNE.derived.gerp.bed > $CALLING.UCNE.derived_lt2.gerp.bed
awk -F"\t|:|-" '($4 > 2 && $4 <= 5) {print $0}' $CALLING.UCNE.derived.gerp.bed | less -S > $CALLING.UCNE.derived_gt2lt5.gerp.bed
awk -F"\t|:|-" '($4 > 5) {print $0}' $CALLING.UCNE.derived.gerp.bed > $CALLING.UCNE.derived_gt5.gerp.bed

```

##Analyse GERP score distribution.
###For all UCNE sites.
####Prepare GERP score distribution file.
```{bash}

#From outside the server, download the bed file to the local folder:
CALLING=(c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov)
scp dkleinman@genomics-b.ebd.csic.es:/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis/GRCH37.$CALLING.UCNE.equivalence.detailed.gerp.bed /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/GERP_analysis

cd /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/GERP_analysis
cut -f11 GRCH37.$CALLING.UCNE.equivalence.detailed.gerp.bed > GRCH37.$CALLING.UCNE.gerp_distribution.gerp

```

####Draw GERP score distribution.
```{r Other stuff}

library(readr)
library(dplyr)
library(ggplot2)

#Prepare files:
gerp_distribution <- read_tsv("/Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/GERP_analysis/GRCH37.c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.gerp_distribution.gerp",col_names=c("GERP"))
gerp_distribution

plot_data <- gerp_distribution %>% group_by(GERP) %>% tally()
plot_data

#First draw the GERP distribution:
GERP_distr_ggplot <- ggplot(data=plot_data, aes(GERP,n)) +
#geom_histogram(aes(NM),binwidth=1) +
geom_col(colour="red") +
ggtitle("UCNE GERP distribution") +
scale_x_continuous(breaks=seq(-12,6,by=1),labels=seq(-12,6,by=1)) +
xlab("GERP score") +
ylab("count") +
theme_bw() +
theme(text=element_text(size=12,face="bold"),
      rect=element_rect(size=1),
      axis.line=element_line(colour="black"),
      axis.title=element_text(size=16),
      #axis.text.x=element_text(angle=45, hjust=1, size=24,colour="black"),
      #axis.text.y=element_text(size=24,colour="black",margin=margin(t=0.5,unit="cm")),
      #axis.title.y=element_text(size=30,margin=margin(r=0.5,unit="cm")),
      panel.background=element_blank(),
      panel.border=element_rect(colour="black"),
      #panel.grid=element_blank(),
      #panel.grid.major=element_line(colour="grey", linetype="dashed", size=0.4),
      plot.margin=unit(c(0.5,1,0.5,0.5),"cm"),
      #plot.title=element_text(size=36, face="bold", margin=margin(b=0.5, unit="cm")),
      legend.background=element_rect(linetype="solid", colour="black", size=.5),
      #legend.justification=c(0,0),
      legend.key=element_rect(colour="white"),
      #legend.key.size=unit(1.3,"cm"),
      legend.position=c(0.92,0.86),
      legend.title=element_blank()
)
GERP_distr_ggplot
ggsave("c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.gerp_distribution.pdf", width=15, height=10, units="cm", device="pdf", path="/Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/GERP_analysis/")

#Draw proportion of reads at different GERP scores:
reads_totales <- sum(plot_data$n)
plot_bis <- mutate(plot_data,prop=as.numeric(100*n/reads_totales))
plot_bis$cum_prop <- cumsum(plot_bis$prop)

GERP_freq_ggplot <- ggplot(data=plot_bis, aes(GERP,cum_prop)) +
#geom_histogram(aes(NM),binwidth=1) +
geom_point() +
ggtitle("Proportion of sites at different GERP scores") +
scale_x_continuous(breaks=seq(-12,6,by=1),labels=seq(-12,6,by=1)) +
xlab("GERP score") +
ylab("percentage (cumulative)") +
theme_bw() +
theme(text=element_text(size=12,face="bold"),
      rect=element_rect(size=1),
      axis.line=element_line(colour="black"),
      axis.title=element_text(size=16),
      #axis.text.x=element_text(angle=45, hjust=1, size=24,colour="black"),
      #axis.text.y=element_text(size=24,colour="black",margin=margin(t=0.5,unit="cm")),
      #axis.title.y=element_text(size=30,margin=margin(r=0.5,unit="cm")),
      panel.background=element_blank(),
      panel.border=element_rect(colour="black"),
      #panel.grid=element_blank(),
      #panel.grid.major=element_line(colour="grey", linetype="dashed", size=0.4),
      plot.margin=unit(c(0.5,1,0.5,0.5),"cm"),
      #plot.title=element_text(size=36, face="bold", margin=margin(b=0.5, unit="cm")),
      legend.background=element_rect(linetype="solid", colour="black", size=.5),
      #legend.justification=c(0,0),
      legend.key=element_rect(colour="white"),
      #legend.key.size=unit(1.3,"cm"),
      legend.position=c(0.92,0.86),
      legend.title=element_blank()
)
GERP_freq_ggplot
ggsave("c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.gerp_cum_proportion.pdf", width=15, height=10, units="cm", device="pdf", path="/Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/GERP_analysis/")

```

####Calculate proportion of sites for each GERP category.
```{bash}

CALLING=(c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov)
cd /GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis/

TOTAL_N=$(wc -l < $CALLING.UCNE.gerp.bed) #1282672
LT2_N=$(awk -F"\t|:|-" '($4 <= 2) {print $0}' $CALLING.UCNE.gerp.bed | wc -l) #38061
LT2_PROP=$(echo "scale=4; $LT2_N/$TOTAL_N" | bc) #0.030
LT2_DER_N=$(awk -F"\t|:|-" '($4 <= 2) {print $0}' $CALLING.UCNE.derived.gerp.bed | wc -l) #132
LT2_DER_PROP=$(echo "scale=6; $LT2_DER_N/$LT2_N" | bc) #0.00347
GT2LT5_N=$(awk -F"\t|:|-" '($4 > 2 && $4 <= 5) {print $0}' $CALLING.UCNE.gerp.bed | wc -l) #337852
GT2LT5_PROP=$(echo "scale=4; $GT2LT5_N/$TOTAL_N" | bc) #0.263
GT2LT5_DER_N=$(awk -F"\t|:|-" '($4 > 2 && $4 <= 5) {print $0}' $CALLING.UCNE.derived.gerp.bed | wc -l) #341
GT2LT5_DER_PROP=$(echo "scale=6; $GT2LT5_DER_N/$GT2LT5_N" | bc) #0.00101
GT5_N=$(awk -F"\t|:|-" '($4 > 5) {print $0}' $CALLING.UCNE.gerp.bed | wc -l) #906759
GT5_PROP=$(echo "scale=4; $GT5_N/$TOTAL_N" | bc) #0.707
GT5_DER_N=$(awk -F"\t|:|-" '($4 > 5) {print $0}' $CALLING.UCNE.derived.gerp.bed | wc -l) #397
GT5_DER_PROP=$(echo "scale=6; $GT5_DER_N/$GT5_N" | bc) #0.00044

```

###For derived UCNE sites.
####Prepare GERP score distribution file.
```{bash}

#From outside the server, download the bed file to the local folder:
CALLING=(c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov)
scp dkleinman@genomics-b.ebd.csic.es:/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani/nmVCFs/$CALLING/annotation/ucne_database/gerp_analysis/$CALLING.UCNE.derived.gerp.bed /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/GERP_analysis

cd /Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/GERP_analysis
cut -f4 $CALLING.UCNE.derived.gerp.bed > $CALLING.UCNE.derived.gerp_distribution.gerp

```

####Draw GERP score distribution.
```{r Other stuff}

library(readr)
library(dplyr)
library(ggplot2)

#Prepare files:
gerp_distribution <- read_tsv("/Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/GERP_analysis/c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.derived.gerp_distribution.gerp",col_names=c("GERP"))
gerp_distribution

plot_data <- gerp_distribution %>% group_by(GERP) %>% tally()
plot_data

#First draw the GERP distribution:
GERP_distr_ggplot <- ggplot(data=plot_data, aes(GERP,n)) +
#geom_histogram(aes(NM),binwidth=1) +
geom_col(colour="red") +
ggtitle("UCNE derived GERP distribution") +
scale_x_continuous(breaks=seq(-12,6,by=1),labels=seq(-12,6,by=1)) +
xlab("GERP score") +
ylab("count") +
theme_bw() +
theme(text=element_text(size=12,face="bold"),
      rect=element_rect(size=1),
      axis.line=element_line(colour="black"),
      axis.title=element_text(size=16),
      #axis.text.x=element_text(angle=45, hjust=1, size=24,colour="black"),
      #axis.text.y=element_text(size=24,colour="black",margin=margin(t=0.5,unit="cm")),
      #axis.title.y=element_text(size=30,margin=margin(r=0.5,unit="cm")),
      panel.background=element_blank(),
      panel.border=element_rect(colour="black"),
      #panel.grid=element_blank(),
      #panel.grid.major=element_line(colour="grey", linetype="dashed", size=0.4),
      plot.margin=unit(c(0.5,1,0.5,0.5),"cm"),
      #plot.title=element_text(size=36, face="bold", margin=margin(b=0.5, unit="cm")),
      legend.background=element_rect(linetype="solid", colour="black", size=.5),
      #legend.justification=c(0,0),
      legend.key=element_rect(colour="white"),
      #legend.key.size=unit(1.3,"cm"),
      legend.position=c(0.92,0.86),
      legend.title=element_blank()
)
GERP_distr_ggplot
ggsave("c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.derived.gerp_distribution.pdf", width=15, height=10, units="cm", device="pdf", path="/Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/GERP_analysis/")

#Draw proportion of reads at different GERP scores:
reads_totales <- sum(plot_data$n)
plot_bis <- mutate(plot_data,prop=as.numeric(100*n/reads_totales))
plot_bis$cum_prop <- cumsum(plot_bis$prop)

GERP_freq_ggplot <- ggplot(data=plot_bis, aes(GERP,cum_prop)) +
#geom_histogram(aes(NM),binwidth=1) +
geom_point() +
ggtitle("Proportion of derived sites at different GERP scores") +
scale_x_continuous(breaks=seq(-12,6,by=1),labels=seq(-12,6,by=1)) +
xlab("GERP score") +
ylab("percentage (cumulative)") +
theme_bw() +
theme(text=element_text(size=12,face="bold"),
      rect=element_rect(size=1),
      axis.line=element_line(colour="black"),
      axis.title=element_text(size=16),
      #axis.text.x=element_text(angle=45, hjust=1, size=24,colour="black"),
      #axis.text.y=element_text(size=24,colour="black",margin=margin(t=0.5,unit="cm")),
      #axis.title.y=element_text(size=30,margin=margin(r=0.5,unit="cm")),
      panel.background=element_blank(),
      panel.border=element_rect(colour="black"),
      #panel.grid=element_blank(),
      #panel.grid.major=element_line(colour="grey", linetype="dashed", size=0.4),
      plot.margin=unit(c(0.5,1,0.5,0.5),"cm"),
      #plot.title=element_text(size=36, face="bold", margin=margin(b=0.5, unit="cm")),
      legend.background=element_rect(linetype="solid", colour="black", size=.5),
      #legend.justification=c(0,0),
      legend.key=element_rect(colour="white"),
      #legend.key.size=unit(1.3,"cm"),
      legend.position=c(0.92,0.86),
      legend.title=element_blank()
)
GERP_freq_ggplot
ggsave("c_lp_sm_c_lp_do_c_ll_ki_c_ll_no_c_ll_po_nm2nm3_origcov.UCNE.derived.gerp_cum_proportion.pdf", width=15, height=10, units="cm", device="pdf", path="/Users/dani/ownCloud/backup/g-w_analysis/genetic_load/ucne_db/GERP_analysis/")

```
