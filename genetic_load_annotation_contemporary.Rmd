---
title: "genetic_load_annotation_contemporary"
author: "Dani"
date: "6 de junio de 2017"
output: html_document
---

http://snpeff.sourceforge.net/SnpEff_manual.html #I'll be following this manual for all SnpEff configuration purposes

#0: Define paths.

```{r Define paths, eval=FALSE, engine='bash'}

S_PATH=/opt/snpEff #software path
C_PATH=/home/dkleinman/datos/snpEff #config file path
O_PATH=/home/dkleinman/datos/snpEff #output path
I_PATH=/home/GRUPOS/grupolince/immunocapture/prueba_highdiv #immunocapture path
V_PATH=/home/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani #VCFs path
G_PATH=/home/GRUPOS/grupolince/lynx_genomes_5x/gVCFs #gVCFs path
REF=/home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa #path to reference genome
GATK=/opt/GATK-3.7/GenomeAnalysisTK.jar #GATK software path
BCF=/opt/bcftools-1.6/bcftools #BCFtools software path

```

#1: Polarize contemporary VCF. Use VCFtools in order to polarize (ancestral vs. derived) the contemporary ll & lp VCF. The ancestral state was inferred by Maria.
##Option A: add Ancestral Allele annotation to the VCF, and then polarize it.

###Use vcftools to fill the INFO/AA field of the VCF.

```{r Polarize contemporary VCF, eval=FALSE, engine='bash'}

#This is the command to use in order to add to a VCF information on the ancestral/derived alleles: /opt/vcftools_0.1.13/perl/fill-aa. There's documentation inside that command that I'll follow here.

#First, the ancestral alleles file should be bgzipped (according to the documentation, they should be gzipped, but later on when trying to run faidx I got an error stating that files should be gzipped in order to build a fai index):
bgzip -c /home/GRUPOS/grupolince/reference_genomes/lynx_rufus_genome/c_lr_zz_0001_recal1.fa > /home/GRUPOS/grupolince/reference_genomes/lynx_rufus_genome/c_lr_zz_0001_recal1.fa.gz

#Next they should be fai indexed:
/opt/samtools-1.6/samtools faidx /home/GRUPOS/grupolince/reference_genomes/lynx_rufus_genome/c_lr_zz_0001_recal1.fa.gz

#Code to annotate the AA (ancestral alleles) subfield from the INFO field in the VCF. I keep getting the following error: "Can't locate Vcf.pm in @INC". I look it up and apparently it's easy to solve: an environment variable PERL5LIB should be defined as the path to perl.
screen -S c_ll_lp_plus_h_ll_aafilled_vcf.log
script c_ll_lp_plus_h_ll_aafilled_vcf.log

export PERL5LIB=/opt/vcftools_0.1.13/perl/ #set required environmental variable
V_PATH=/home/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani #VCFs path

cat $V_PATH/c_ll_lp_plus_h_ll_renamed.vcf | /opt/vcftools_0.1.13/perl/fill-aa -a /home/GRUPOS/grupolince/reference_genomes/lynx_rufus_genome/c_lr_zz_0001_recal1.fa.gz | bgzip -c > c_ll_lp_plus_h_ll_aafilled.vcf.gz #I tried to run this first without bgzipping it, and it was increasingly slow. Each day it did around half the previous day. When the server crashed, I relaunched it adding the bgzip command and it finished in a little over 24h.

#Test the VCF polarization using Federico Abascal's perl code:
perl /home/dkleinman/datos/snpEff/data/polarize_vcf_fabascal.pl test.ann.vcf > test_polarized.ann.vcf #it doesn't work...

```

###Use VcfFilterJdk to polarize the annotated VCF.

```{r Polarize contemporary VCF, eval=FALSE, engine='bash'}

#Polarize the AA-filled VCF based on the new INFO/AA column. Alleles will be switched whenever the ancestral allele matches the alternative one, and genotypes will be properly recoded as well.

#So far, the current code yields the following error: "Allele C* is not an allele in the variant context". I contacted the author in case he knows what to do next.

java -jar /opt/jvarkit/dist/vcffilterjdk.jar -e 'if(variant.getNAlleles()!=2 || !variant.hasAttribute("AA")) return true;
final String aa = variant.getAttributeAsString("AA","");
if(!variant.getAlleles().get(1).getDisplayString().equalsIgnoreCase(aa)) return true;
VariantContextBuilder vb=new VariantContextBuilder(variant);

Allele oldalt =  variant.getAlleles().get(1);
Allele oldref =  variant.getAlleles().get(0);
Allele ref= Allele.create(oldalt.getDisplayString(),true);
Allele alt= Allele.create(oldref.getDisplayString(),false);

vb.alleles(Arrays.asList(ref,alt));

List<Genotype> genotypes= new ArrayList<>();
for(Genotype g: variant.getGenotypes())
    {
    if(!g.isCalled()) { genotypes.add(g); continue;}
    GenotypeBuilder gb = new GenotypeBuilder(g);
    List<Allele> alleles = new ArrayList<>();
    for(Allele a:g.getAlleles())
        {
        if(a.equals(oldalt)) { a=ref;}
        else if(a.equals(oldref)) { a=alt;}
        alleles.add(a);
        }
    if(g.hasPL()) {
        int pl[] = g.getPL();
        int pl2[] = new int[pl.length];
        for(int i=0;i< pl.length;i++) pl2[i]=pl[(pl.length-1)-i];
        gb.PL(pl2);
        }
    genotypes.add(gb.alleles(alleles).make());
    }

vb.attribute("AC",variant.getGenotypes().stream().flatMap(G->G.getAlleles().stream()).filter(A->A.equals(oldref)).count());
vb.genotypes(genotypes);
return vb.make();' -o test_polarized.ann.vcf test.ann.vcf

vb.attribute("AF",(variant.getGenotypes().stream().flatMap(G->G.getAlleles().stream()).filter(A->A.equals(oldref)).count())/(variant.getGenotypes().stream().flatMap(G->G.getAlleles().stream()).count()));

```

##Option B: generate new VCF with the ancestral state as the reference. Use GATK to make a calling with lynx rufus as the reference.

```{r Polarize contemporary VCF, eval=FALSE, engine='bash'}

#Another option is to generate a new VCF using the ancestral as the reference... But this didn't work as intended. REF alleles were still those of the Iberian lynx reference genome, maybe because the gVCFs were first called against it. In the end option A was used.

#First, the reference genome should be properly indexed as follows:
cd /home/GRUPOS/grupolince/reference_genomes/lynx_rufus_genome/
java -jar /home/tmp/Software/Picard/picard-tools-1.66/CreateSequenceDictionary.jar \
 R=c_lr_zz_0001_recal1.fa \
 O=c_lr_zz_0001_recal1.dict

#Then, combine all gVCFs into a single VCF using the ancestral state as the reference:
cd $G_PATH
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -jar $GATK \
-T GenotypeGVCFs \
-R /home/GRUPOS/grupolince/reference_genomes/lynx_rufus_genome/c_lr_zz_0001_recal1.fa \
$(for var in *.g.vcf.gz; do echo -V ${var}" ";done) \
-o $V_PATH/c_ll_lp_plus_h_ll_ancestral_ref.vcf

```

#2: Extract SNPs. Subset the VCF files in order to keep only good quality biallelic SNP variants. INDELs, multiallelic SNPs and bad quality SNPs will be dropped at this step.

```{r Extract SNPs, eval=FALSE, engine='bash'}

#During this step, all INDELs as well as all multiallelic and bad quality SNPs will be dropped from the respective VCFs.
screen -S c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_vcf.log
script c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_vcf.log

cd $V_PATH
java -XX:MaxMetaspaceSize=1g -XX:+UseG1GC -XX:+UseStringDeduplication -Xms16g -Xmx32g -jar $GATK \
-T SelectVariants \
-selectType SNP \
-restrictAllelesTo BIALLELIC \
-select "QD >= 2.0 && FS <= 60.0 && MQ >= 40.0 && MQRankSum >= -12.5 && ReadPosRankSum >= -8.0" \
-R $REF \
-V c_ll_lp_plus_h_ll_aafilled.vcf \
-o c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter.vcf

!!!! REVIEW OTHER FILTERS
!!!! REMOVE REPETITIONS

```

#3: Set up SnpEff.
##Search for the Lynx pardinus database. 
Search for the Lynx pardinus assembly database in the program's pre-built database. As of June the 6th, 2017, the Lynx pardinus genome isn't included in the snpEff database. A second option would be building our own Lynx pardinus database.

```{r Set up SnpEff, eval=FALSE, engine='bash'}

java -jar /opt/snpEff/snpEff.jar databases | grep -i pardinus

```

##Build the Lynx pardinus genome database.
In the end we opt to build our own database since we don't know when they will get themselves to add it. This step should be omitted if the desired database was found in the previous step.

###Add entry to the config file

```{r Set up SnpEff, eval=FALSE, engine='bash'}

#Originally the config was just in the software folder and I didn't have writing permission. If this is the only config file available, writing permission is required, and when annotating later on, the file should be called using the -c command followed by the path to the file.
#However, in my case I believe the tech group created a copy of the file in my folder after I sent them an e-mail, and this is the one that I was able to edit.

cd /home/dkleinman/
mv snpEff.config $C_PATH #I move the config file that appeared in my folder to a subfolder that I created for snpEff
vi snpEff.config  #initiate the editing process

#Following the manual, I added the following two lines:

# Lynx_pardinus
LYPA.23.genome : Iberian lynx #from now on, LYPA.23 is the code for the Lynx pardinus reference genome (in snpEff)

# Lynx_pardinus, detailed annotation (obsolete)
LYPA.23b.genome : Iberian lynx #LYPA.23b is the code for the highly detailed annotation of the Lynx pardinus reference genome (in snpEff)

```

###Create directory and move files

```{r Set up SnpEff, eval=FALSE, engine='bash'}

#First for the regular annotation:
mkdir $S_PATH/data/LYPA.23 #create a directory inside the software's dependencies whose name matches the code
cd $S_PATH/data/LYPA.23

scp /GRUPOS/grupolince/Lyp_annotation_Apr14_final/LYPA23C.all.fix.nr.gff3 $S_PATH/data/LYPA.23/ #copy the annotation file (can be gff or gtf) to the newly created directory. This gff file includes CDS, introns, exons and genes, so it's very basic. A more complex version that Maria created which includes lncRNAs, etc., could be tested in the future.
mv LYPA23C.all.fix.nr.gff3 genes.gff #rename the file as the tutorial indicates

mkdir $S_PATH/data/genomes #create a directory inside the software's dependencies called genomes
cd $S_PATH/data/genomes
scp /home/GRUPOS/grupolince/reference_genomes/lynx_pardinus_genome/lp23.fa $S_PATH/data/genomes #copy the reference genome fasta to the new genomes directory
mv lp23.fa LYPA.23.fa #rename the file so that it matches the code


#In the end this won't be used. The detailed (custom) annotation will be intersected using a bed and the -interval command.
#Second, for the detailed annotation:
mkdir $C_PATH/data/LYPA.23b #create a directory inside the software's dependencies whose name matches the code
cd $C_PATH/data/LYPA.23b

scp /GRUPOS/grupolince/Lyp_annotation_Apr14_final/LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.intergenic.nr.gff3 $C_PATH/data/LYPA.23b/ #copy the annotation file (can be gff or gtf) to the newly created directory. This gff file is very detailed and includes CDS, introns, exons, genes, and many more.
mv LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.intergenic.nr.gff3 genes.gff #rename the file as the tutorial indicates

cd $C_PATH/data/genomes
scp LYPA.23.fa LYPA.23b.fa #copy the reference genome and rename it so that it also matches the detailed annotation entry

```

###Build the database

```{r Set up SnpEff, eval=FALSE, engine='bash'}

cd $C_PATH
screen -S build_snpEff_db #open a dettachable screen in case the database building takes too long
script build_snpEff_db.txt #initiate the log file

S_PATH=/opt/snpEff #redefine the variable, since we're inside a script
C_PATH=/home/dkleinman/datos/snpEff #redefine the variable, since we're inside a script

cd $S_PATH
java -jar snpEff.jar build -gff3 -v LYPA.23 -c $C_PATH/snpEff.config -dataDir $C_PATH/data #build the database. Use the -gff3 command for gff files and -gtf22 for gtf files. Use -v for verbose (expanded information on the processes and the warnings/errors that may appear). Use -c to indicate the path to my own config file. Then use -dataDir to override the data directory from the config file (by default the software thinks that the data folder with the genome and the genes files is located where config is, so it's necessary to give it the correct path). Another option would be running it from the config folder and indicating instead the 

ctrl + D #terminate the script
ctrl + D #terminate the screen

#The following is obsolete since I fixed the original code.
scp -r $S_PATH/data $C_PATH #afterwards I realize anyone can access the data folder so I copy it to my own folder and then I remove the stuff I created inside the original data folder
cd $S_PATH/data
rm -r LYPA.23/
rm -r genomes/

```

### Tutorial annotation
Annotate one of the examples that comes with the software

```{r Tutorial annotation, eval=FALSE, engine='bash'}

java -Xmx16g -jar $S_PATH/snpEff.jar GRCh37.75 -s $O_PATH/toys/test.chr22.ann $S_PATH/examples/test.chr22.vcf > $O_PATH/toys/test.chr22.ann.vcf

```

#4: Variants annotation (detailed).
##Create custom annotation bed file

```{r Variants annotation (detailed), eval=FALSE, engine='bash'}

#Create bed file with custom annotations based on the gff3 that María compiled.
cut -d$'\t' -f1,3,4,5 /GRUPOS/grupolince/Lyp_annotation_Apr14_final/LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.intergenic.nr.gff3 | awk '{printf ("%s\t%s\t%s\t%s\n", $1, $3, $4, $2)}' > /home/dkleinman/datos/snpEff/data/LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.intergenic.nr.bed

```

##Annotate the VCF with custom annotation

```{r Variants annotation (detailed), eval=FALSE, engine='bash'}

cd $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/
screen -S c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter.ann.log #open a dettachable screen in case the test takes too long
script c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter.ann.log #initiate the log file

S_PATH=/opt/snpEff #software path
C_PATH=/home/dkleinman/datos/snpEff #config file path
O_PATH=/home/dkleinman/datos/snpEff #output path
I_PATH=/home/GRUPOS/grupolince/immunocapture/prueba_highdiv #immunocapture path
V_PATH=/home/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani #VCFs path

cd $C_PATH
java -Xmx16g -jar $S_PATH/snpEff.jar LYPA.23 -v -s $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter.ann.html -csvStats $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter.ann.csv -interval $C_PATH/data/LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.intergenic.nr.bed $V_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter.vcf > $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter.ann.vcf #run this code from the directory where the config is located.

```

#5: Get annotation statistics for each population.
##Split the VCF into per population VCFs. Generate a VCF for each population.

```{r Get annotation statistics for each population, eval=FALSE, engine='bash'}

#Split the annotated VCF into per population VCFs, and then keep only those positions that are variable or fixed for the derived allele within each population.

cd $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/perpop/
screen -S c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_perpop.ann.log
script c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_perpop.ann.log

cd $G_PATH
declare POP=$(ls c_{lp_sm*,lp_do*,ll_ki*,ll_po*,ll_no*}.g.vcf.gz | cut -c1-7 | uniq)
cd $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/perpop/
for i in ${POP[@]}
  do
  echo "${i}"
  $BCF query -l $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter.ann.vcf | grep "${i}" > list_to_remove.txt
  $BCF view -S list_to_remove.txt -Ov -o $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/perpop/"${i}"_aafilled_SNPs_standard_filter_perpop_all.ann.vcf $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter.ann.vcf
  $BCF view -i '(INFO/AA == REF && INFO/AC > 0) || (INFO/AA == ALT && INFO/AC < INFO/AN) || (INFO/AA != REF && INFO/AA != ALT)' -Ov -o $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/perpop/"${i}"_aafilled_SNPs_standard_filter_perpop_trimmed.ann.vcf $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/perpop/"${i}"_aafilled_SNPs_standard_filter_perpop_all.ann.vcf
  done
rm list_to_remove.txt

```

##Get snpEff stats for each population

```{r Get annotation statistics for each population, eval=FALSE, engine='bash'}

cd $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/perpop/
screen -S c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_perpop_snpeff.ann.log #open a dettachable screen in case the test takes too long
script c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_perpop_snpeff.ann.log #initiate the log file

S_PATH=/opt/snpEff #software path
C_PATH=/home/dkleinman/datos/snpEff #config file path
O_PATH=/home/dkleinman/datos/snpEff #output path
I_PATH=/home/GRUPOS/grupolince/immunocapture/prueba_highdiv #immunocapture path
V_PATH=/home/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani #VCFs path

cd $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/perpop/
POPLIST=($(ls *trimmed.ann.vcf))
for pop in "${POPLIST[@]}"
  do
  echo "${pop}"
  #done
  cd $C_PATH
  java -Xmx16g -jar $S_PATH/snpEff.jar LYPA.23 -v -s $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/perpop/${pop/trimmed.ann.vcf/trimmed_snpeff.ann.html} -csvStats $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/perpop/${pop/trimmed.ann.vcf/trimmed_snpeff.ann.csv} -interval $C_PATH/data/LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.intergenic.nr.bed $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/perpop/${pop} > $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/perpop/${pop/trimmed.ann.vcf/trimmed_snpeff.ann.vcf} #run this code from the directory where the config is located.
done

```

##Build SnpEff summary file.

```{r Get annotation statistics for each population, eval=FALSE, engine='bash'}

cd $O_PATH/c_ll_lp_plus_h_ll_aafilled_SNPs_standard_filter_detailed_annotation/perpop/
echo "species,population,N_intergenic,N_intronic,N_exonic,N_missense,N_nonsense,N_silent,N_missense/silent" > snpeff_population_summary.borrar
POPLIST=($(ls c_{lp_sm*,lp_do*,ll_ki*,ll_po*,ll_no*}.vcf))
for pop in "${POPLIST[@]}"
  do
  SPECIES=$(echo "${pop}" | cut -c1-2)
  POPULATION=$(echo "${pop}" | cut -c4-5)
  N_INTERGENIC=$(grep 'INTERGENIC' ${pop} | wc -l)
  N_INTRONIC=$(grep 'INTRON' ${pop} | wc -l)
  N_EXONIC=$(grep 'EXON' ${pop} | wc -l)
  N_MISSENSE=$(grep 'MISSENSE' ${pop} | wc -l)
  N_NONSENSE=$(grep 'NONSENSE' ${pop} | wc -l)
  N_SILENT=$(grep 'SILENT' ${pop} | wc -l)
  N_MISSENSE_SILENT=$(grep 'Missense_Silent_ratio' ${pop} | wc -l)
  echo "$SPECIES,$POPULATION,$N_INTERGENIC,$N_INTRONIC,$N_EXONIC,$N_MISSENSE,$N_NONSENSE,$N_SILENT,$N_MISSENSE_SILENT" >> snpeff_population_summary.borrar
  done
cat snpeff_population_summary.borrar | tr -d "[:blank:]" > snpeff_population_summary.txt
cat snpeff_population_summary.txt
rm *.borrar

```


#Xa: Trim contemporary population lp and ll VCFs. Trim previously generated VCFs with species-wide variants in order to keep populational variants only.

```{r Trim contemporary population lp and ll VCFs, eval=FALSE, engine='bash'}

#Fixed positions within each population VCF will be dropped and only the variable ones will remain. These VCFs were previously generated in the c_lp_ll_VCF script.
cd $V_PATH
declare POP=$(ls *perpop*.vcf | cut -c1-5 | uniq)
for i in ${POP[@]}
  do
  echo "${i}"
  $BCF view --min-ac 1:minor -Ov -o $V_PATH/trimmed_VCFs/"${i}"_perpop_standard_filter.trimmed.vcf $V_PATH/"${i}"_perpop_standard_filter.vcf
  done

```

#Xb: Population annotation (detailed) using the contemporary lp and ll VCFs.

##Create custom annotation bed file

```{r Population annotation (detailed) using the contemporary lp and ll VCFs, eval=FALSE, engine='bash'}

#Create bed file with custom annotations based on the gff3 that María compiled.
cut -d$'\t' -f1,3,4,5 LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.intergenic.nr.gff3 | awk '{printf ("%s\t%s\t%s\t%s\n", $1, $3, $4, $2)}' > LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.intergenic.nr.bed

```

##Annotate the contemporary population VCFs with custom annotation

```{r Population annotation (detailed) using the contemporary lp and ll VCFs, eval=FALSE, engine='bash'}

cd $O_PATH/c_ll_lp_perpop_standard_filter_detailed_annotation/
screen -S c_ll_lp_perpop_standard_filter_detailed_annotation.log #open a dettachable screen in case the test takes too long
script /home/dkleinman/datos/snpEff/c_ll_lp_perpop_standard_filter_detailed_annotation/c_ll_lp_perpop_standard_filter_detailed_annotation.log #initiate the log file

S_PATH=/opt/snpEff #software path
C_PATH=/home/dkleinman/datos/snpEff #config file path
O_PATH=/home/dkleinman/datos/snpEff #output path
I_PATH=/home/GRUPOS/grupolince/immunocapture/prueba_highdiv #immunocapture path
V_PATH=/home/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani #VCFs path

cd $V_PATH/trimmed_VCFs
shopt -s extglob #the extglob shell option gives you more powerful pattern matching in the command line.
POPLIST=($(ls l*[^pv]_perpop_standard_filter.trimmed.vcf)) #selects all standard-filtered populational VCFs except for País Vasco
for pop in "${POPLIST[@]}"
  do
  echo "${pop}"
  #done
  cd $C_PATH
  java -Xmx16g -jar $S_PATH/snpEff.jar LYPA.23 -v -s $O_PATH/c_ll_lp_perpop_standard_filter_detailed_annotation/${pop/.vcf/.ann.html} -csvStats $O_PATH/c_ll_lp_perpop_standard_filter_detailed_annotation/${pop/.vcf/.ann.csv} -interval $C_PATH/data/LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.intergenic.nr.bed $V_PATH/trimmed_VCFs/${pop} > $O_PATH/c_ll_lp_perpop_standard_filter_detailed_annotation/${pop/.vcf/.ann.vcf} #run this code from the directory where the config is located.
done
shopt -u extglob #disable extglob

scp dkleinman@genomics-b.ebd.csic.es:/home/dkleinman/datos/snpEff/c_ll_lp_perpop_standard_filter_detailed_annotation/l*csv /Users/Dani/ownCloud/backup/annotation/snpEff_results/c_ll_lp_perpop_standard_filter_detailed_annotation/
scp dkleinman@genomics-b.ebd.csic.es:/home/dkleinman/datos/snpEff/c_ll_lp_perpop_standard_filter_detailed_annotation/*html /Users/Dani/ownCloud/backup/annotation/snpEff_results/c_ll_lp_perpop_standard_filter_detailed_annotation/
#scp dkleinman@genomics-b.ebd.csic.es:/home/dkleinman/datos/snpEff/c_ll_lp_perpop_standard_filter_detailed_annotation/l*txt /Users/Dani/ownCloud/backup/annotation/snpEff_results/c_ll_lp_perpop_standard_filter_detailed_annotation/

```

##Build SnpEff summary file.

```{r Population annotation (detailed) using the contemporary lp and ll VCFs, eval=FALSE, engine='bash'}

cd $O_PATH/c_ll_lp_perpop_standard_filter_detailed_annotation/
echo "species,population,N_intergenic,N_intronic,N_exonic,N_missense,N_nonsense,N_silent,N_missense/silent" > snpeff_population_summary.borrar
POPLIST=($(ls {lp_sm*,lp_do*,ll_ki*,ll_po*,ll_no*}.csv))
for pop in "${POPLIST[@]}"
  do
  SPECIES=$(echo "${pop}" | cut -c1-2)
  POPULATION=$(echo "${pop}" | cut -c4-5)
  N_INTERGENIC=$(grep 'INTERGENIC' ${pop} | cut -d  "," -f2)
  N_INTRONIC=$(grep 'INTRON' ${pop} | cut -d  "," -f2)
  N_EXONIC=$(grep 'EXON' ${pop} | cut -d  "," -f2)
  N_MISSENSE=$(grep 'MISSENSE' ${pop} | cut -d  "," -f2)
  N_NONSENSE=$(grep 'NONSENSE' ${pop} | cut -d  "," -f2)
  N_SILENT=$(grep 'SILENT' ${pop} | cut -d  "," -f2)
  N_MISSENSE_SILENT=$(grep 'Missense_Silent_ratio' ${pop} | cut -d  "," -f2)
  echo "$SPECIES,$POPULATION,$N_INTERGENIC,$N_INTRONIC,$N_EXONIC,$N_MISSENSE,$N_NONSENSE,$N_SILENT,$N_MISSENSE_SILENT" >> snpeff_population_summary.borrar
  done
cat snpeff_population_summary.borrar | tr -d "[:blank:]" > snpeff_population_summary.txt
cat snpeff_population_summary.txt
rm *.borrar

```

#Xc: Individual annotation (detailed) using the contemporary lp and ll VCFs.

##Split the population VCFs into per individual VCFs. Generate a VCF for each individual.

```{r Individual annotation (detailed) using the contemporary lp and ll VCFs, eval=FALSE, engine='bash'}

cd $V_PATH/individual_VCFs/
screen -S bcfstats_individual_trimmed_standard_filter_vcfs.log
script bcfstats_individual_trimmed_standard_filter_vcfs.log

#For each individual in the sm, do, ki, po & no populations, subset its variants from the respective population VCF:
cd $G_PATH
declare POP=$(ls c_{lp_sm*,lp_do*,ll_ki*,ll_po*,ll_no*}.g.vcf.gz | cut -c3-7 | uniq)
for i in ${POP[@]}
  do
  echo "${i}"
  declare INDIVIDUALS=$(ls c_"${i}"*.g.vcf.gz | cut -c1-12 | uniq)
  for j in ${INDIVIDUALS[@]}
    do
    echo "${j}"
    ID=$(echo "${j}")
    $BCF view --min-ac 1:minor -s $ID -Ov -o $V_PATH/individual_VCFs/"${j}"_standard_filter.trimmed.vcf $V_PATH/trimmed_VCFs/"${i}"_perpop_standard_filter.trimmed.vcf
    echo $V_PATH"/individual_VCFs/"${j}"_standard_filter.trimmed.vcf"
    done
  done

```

##Annotate the contemporary individual VCFs with custom annotation

```{r Individual annotation (detailed) using the contemporary lp and ll VCFs, eval=FALSE, engine='bash'}

cd $O_PATH/c_ll_lp_individual_standard_filter_detailed_annotation/
screen -S c_ll_lp_individual_standard_filter_detailed_annotation.log #open a dettachable screen in case the test takes too long
script /home/dkleinman/datos/snpEff/c_ll_lp_individual_standard_filter_detailed_annotation/c_ll_lp_individual_standard_filter_detailed_annotation.log #initiate the log file

S_PATH=/opt/snpEff #software path
C_PATH=/home/dkleinman/datos/snpEff #config file path
O_PATH=/home/dkleinman/datos/snpEff #output path
I_PATH=/home/GRUPOS/grupolince/immunocapture/prueba_highdiv #immunocapture path
V_PATH=/home/GRUPOS/grupolince/lynx_genomes_5x/VCFs_Dani #VCFs path

cd $V_PATH/individual_VCFs
shopt -s extglob #the extglob shell option gives you more powerful pattern matching in the command line.
INDLIST=($(ls c_{lp_sm*,lp_do*,ll_ki*,ll_po*,ll_no*}.trimmed.vcf)) #selects all individuals from the 5 populations that we picked for this study.
for ind in "${INDLIST[@]}"
  do
  echo "${ind}"
  java -Xmx16g -jar $S_PATH/snpEff.jar LYPA.23 -v -s $O_PATH/c_ll_lp_individual_standard_filter_detailed_annotation/${ind/.vcf/.ann.html} -csvStats $O_PATH/c_ll_lp_individual_standard_filter_detailed_annotation/${ind/.vcf/.ann.csv} -interval $C_PATH/data/LYPA23C.GENE.mRNA.CDS.GENE_promoters.GENE_introns.UTRs.ncRNA.lncRNA.lncRNA_introns.lncRNA_promoters.intergenic.nr.bed $V_PATH/individual_VCFs/${ind} > $O_PATH/c_ll_lp_individual_standard_filter_detailed_annotation/${ind/.vcf/.ann.vcf} #run this code from the directory where the config is located.
done
shopt -u extglob #disable extglob

c_lp_sm_0450_standard_filter.trimmed.ann.csv

scp dkleinman@genomics-b.ebd.csic.es:/home/dkleinman/datos/snpEff/c_ll_lp_individual_standard_filter_detailed_annotation/*csv /Users/Dani/ownCloud/backup/annotation/snpEff_results/c_ll_lp_individual_standard_filter_detailed_annotation/
scp dkleinman@genomics-b.ebd.csic.es:/home/dkleinman/datos/snpEff/c_ll_lp_individual_standard_filter_detailed_annotation/*html /Users/Dani/ownCloud/backup/annotation/snpEff_results/c_ll_lp_individual_standard_filter_detailed_annotation/
#scp dkleinman@genomics-b.ebd.csic.es:/home/dkleinman/datos/snpEff/c_ll_lp_individual_standard_filter_detailed_annotation/l*txt /Users/Dani/ownCloud/backup/annotation/snpEff_results/c_ll_lp_individual_standard_filter_detailed_annotation/

```

##Build SnpEff summary file.

```{r Individual annotation (detailed) using the contemporary lp and ll VCFs, eval=FALSE, engine='bash'}

cd $O_PATH/c_ll_lp_individual_standard_filter_detailed_annotation/
echo "species,population,sample,N_intergenic,N_intronic,N_exonic,N_missense,N_nonsense,N_silent,N_missense/silent" > snpeff_individual_summary.borrar
INDLIST=($(ls *.csv))
for ind in "${INDLIST[@]}"
  do
  SPECIES=$(echo "${ind}" | cut -c3-4)
  POPULATION=$(echo "${ind}" | cut -c6-7)
  SAMPLE=$(echo "${ind}" | cut -c9-12)
  N_INTERGENIC=$(grep 'INTERGENIC' ${ind} | cut -d  "," -f2)
  N_INTRONIC=$(grep 'INTRON' ${ind} | cut -d  "," -f2)
  N_EXONIC=$(grep 'EXON' ${ind} | cut -d  "," -f2)
  N_MISSENSE=$(grep 'MISSENSE' ${ind} | cut -d  "," -f2)
  N_NONSENSE=$(grep 'NONSENSE' ${ind} | cut -d  "," -f2)
  N_SILENT=$(grep 'SILENT' ${ind} | cut -d  "," -f2)
  N_MISSENSE_SILENT=$(grep 'Missense_Silent_ratio' ${ind} | cut -d  "," -f2)
  echo "$SPECIES,$POPULATION,$SAMPLE,$N_INTERGENIC,$N_INTRONIC,$N_EXONIC,$N_MISSENSE,$N_NONSENSE,$N_SILENT,$N_MISSENSE_SILENT" >> snpeff_individual_summary.borrar
  done
cat snpeff_individual_summary.borrar | tr -d "[:blank:]" > snpeff_individual_summary.txt
cat snpeff_individual_summary.txt

```

#Z: Toy annotation using the immunocapture VCF.
Annotate the immunocapture VCF 

```{r Toy annotation using the immunocapture VCF, eval=FALSE, engine='bash'}

cd $C_PATH
screen -S immuno_annot_test1 #open a dettachable screen in case the test takes too long

script immunocapture/immuno_annot_test1.txt #initiate the log file

S_PATH=/opt/snpEff #redefine the variable, since we're inside a script
C_PATH=/home/dkleinman/datos/snpEff #redefine the variable, since we're inside a script
O_PATH=/home/dkleinman/datos/snpEff #redefine the variable, since we're inside a script
I_PATH=/home/GRUPOS/grupolince/immunocapture/prueba_highdiv #write here the input path. This folder only exists in server A, so keep that in mind (I was looking for it for the longest time in server B >.<)

java -Xmx16g -jar $S_PATH/snpEff.jar LYPA.23 -v -s $O_PATH/immunocapture/immunocapture_test1.ann.html $I_PATH/x_lx_xx_n201_filtered.vcf > $O_PATH/immunocapture/immunocapture_test1.ann.vcf #run this code from the directory where the config is located, and from server A (I_PATH doesn't exist in server B). I used the filtered version of the vcf which includes all lynx individuals in the immunocapture; there's also a raw version which can be tested.

ctrl + D #terminate the script
ctrl + D #terminate the screen

scp dkleinman@genomics-b.ebd.csic.es:/home/dkleinman/datos/snpEff/immunocapture/immunocapture_test1.ann* /Users/Dani/ownCloud/backup/annotation/snpEff_results/immunocapture/ #execute this command out of the server to import to the pc the output files of this toy run

```
